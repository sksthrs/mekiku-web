/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/split.js/dist/split.es.js":
/*!************************************************!*\
  !*** ./node_modules/split.js/dist/split.es.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize to an array if it isn't already. This allows minSize\n    // to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Split);\n\n\n//# sourceURL=webpack:///./node_modules/split.js/dist/split.es.js?");

/***/ }),

/***/ "./src/TmpConfig.ts":
/*!**************************!*\
  !*** ./src/TmpConfig.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass TmpConfig {\n    static getName() {\n        if (this.username == null) {\n            this.username = localStorage.getItem('tmp-config-name') || '';\n        }\n        return this.username;\n    }\n    static setName(name) {\n        if (name !== this.username) {\n            this.username = name;\n            localStorage.setItem('tmp-config-name', name);\n        }\n    }\n    static getMemberType() {\n        return this.memberType;\n    }\n    static setMemberType(memberType) {\n        this.memberType = memberType;\n    }\n    static getApiKey() {\n        return this.apiKey;\n    }\n    static setApiKey(key) {\n        this.apiKey = key;\n    }\n    static getDebugLevel() {\n        return this.debugLevel;\n    }\n    static setDebugLevel(level) {\n        this.debugLevel = level;\n    }\n    static getAuthUrl() {\n        return this.authUrl;\n    }\n    static setAuthUrl(url) {\n        this.authUrl = url;\n    }\n}\n// user member-type\nTmpConfig.memberType = '';\n// API key\nTmpConfig.apiKey = '';\nTmpConfig.debugLevel = 1;\nTmpConfig.authUrl = '';\nexports.default = TmpConfig;\n\n\n//# sourceURL=webpack:///./src/TmpConfig.ts?");

/***/ }),

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst mekikuComm_1 = __importStar(__webpack_require__(/*! ./mekikuComm */ \"./src/mekikuComm.ts\"));\nconst log_1 = __importDefault(__webpack_require__(/*! ./log */ \"./src/log.ts\"));\nconst appControlPane_1 = __importDefault(__webpack_require__(/*! ./appControlPane */ \"./src/appControlPane.ts\"));\nconst dialogLogin_1 = __importDefault(__webpack_require__(/*! ./dialogLogin */ \"./src/dialogLogin.ts\"));\nconst paneInput_1 = __webpack_require__(/*! ./paneInput */ \"./src/paneInput.ts\");\nconst paneFkey_1 = __webpack_require__(/*! ./paneFkey */ \"./src/paneFkey.ts\");\nconst paneMonitor_1 = __webpack_require__(/*! ./paneMonitor */ \"./src/paneMonitor.ts\");\nconst content_1 = __webpack_require__(/*! ./content */ \"./src/content.ts\");\nconst memberManager_1 = __webpack_require__(/*! ./memberManager */ \"./src/memberManager.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nconst paneChat_1 = __webpack_require__(/*! ./paneChat */ \"./src/paneChat.ts\");\nconst panePft_1 = __webpack_require__(/*! ./panePft */ \"./src/panePft.ts\");\nconst panePftMon_1 = __webpack_require__(/*! ./panePftMon */ \"./src/panePftMon.ts\");\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst paneMain_1 = __webpack_require__(/*! ./paneMain */ \"./src/paneMain.ts\");\nconst mekikuAnalyzer_1 = __webpack_require__(/*! ./mekikuAnalyzer */ \"./src/mekikuAnalyzer.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nconst paneContainers_1 = __webpack_require__(/*! ./paneContainers */ \"./src/paneContainers.ts\");\nconst fileController_1 = __importStar(__webpack_require__(/*! ./fileController */ \"./src/fileController.ts\"));\nconst dialogConfig_1 = __webpack_require__(/*! ./dialogConfig */ \"./src/dialogConfig.ts\");\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst dialogInput_1 = __importDefault(__webpack_require__(/*! ./dialogInput */ \"./src/dialogInput.ts\"));\nconst TmpConfig_1 = __importDefault(__webpack_require__(/*! ./TmpConfig */ \"./src/TmpConfig.ts\"));\nconst dialogConfigViewer_1 = __webpack_require__(/*! ./dialogConfigViewer */ \"./src/dialogConfigViewer.ts\");\nconst split_js_1 = __importDefault(__webpack_require__(/*! split.js */ \"./node_modules/split.js/dist/split.es.js\"));\nconst dialogNotify_1 = __importDefault(__webpack_require__(/*! ./dialogNotify */ \"./src/dialogNotify.ts\"));\nclass App {\n    constructor() {\n        this.id = \"\";\n        this.roomName = \"\";\n        this.pageTitle = \"\";\n        this.isViewer = false;\n        this.isErrorHandling = false;\n        const localConfig = localStorage.getItem('config');\n        if (localConfig != null) {\n            log_1.default.w('Info', 'config found in localStorage');\n            appConfig_1.AppConfig.trySetJSON(localConfig);\n        }\n        const locale = appConfig_1.AppConfig.data.getLocale();\n        log_1.default.w(\"Info\", `locale:${locale}`);\n        t_1.T.setLocale(locale);\n        window.addEventListener('beforeunload', (ev) => { this.onBeforeUnload(ev); });\n        window.addEventListener('unload', (ev) => { this.onUnload(ev); });\n        utilDom_1.UtilDom.makeDialogsRespondToKey();\n        this.dialogInput = new dialogInput_1.default();\n        this.dialogNotify = new dialogNotify_1.default();\n        this.configFileController = new fileController_1.default('cfg-file-opener');\n        this.dialogConfig = new dialogConfig_1.DialogConfig();\n        this.dialogConfigViewer = new dialogConfigViewer_1.DialogConfigViewer();\n        this.setConfigDialogEvents();\n        const handlers = this.makeCommEventHandlers();\n        this.comm = new mekikuComm_1.default(handlers);\n        this.appControl = new appControlPane_1.default();\n        this.setAppControlEvents();\n        this.paneContainer1 = new paneContainers_1.PaneContainer1();\n        this.paneContainer2 = new paneContainers_1.PaneContainer2();\n        this.paneContainer3 = new paneContainers_1.PaneContainer3();\n        this.dialogLogin = new dialogLogin_1.default();\n        this.setLoginDialogEvents();\n        this.dialogLogin.hidePass(); // no password\n        this.dialogLogin.setName(TmpConfig_1.default.getName());\n        const roomNameRaw = util_1.Util.beforeOf(utilDom_1.UtilDom.getQuery(), '/');\n        if (util_1.Util.isRoomNameLegit(roomNameRaw)) {\n            this.dialogLogin.setRoom(roomNameRaw);\n            this.dialogLogin.hideRoom();\n        }\n        this.updatePageTitle(t_1.T.t(\"Login\", \"Login\"));\n        // Cannot support old browsers (MSIE=IE(<11), Trident=IE11, Edge=EdgeHTML). Chromium Edge('Edg') is okay.\n        if (util_1.Util.contains(navigator.userAgent, 'MSIE', 'Trident', 'Edge')) {\n            // do nothing for no-support browser, so shutter remains topmost.\n        }\n        else {\n            // seems running on not no-support browser. hide shutter and show login dialog.\n            const shutter = document.getElementById('shutter');\n            shutter.style.display = 'none';\n            this.dialogLogin.showDialog();\n        }\n        // fetch config.json\n        fetch(\"config.json\")\n            .then(response => {\n            return response.json();\n        })\n            .then(json => {\n            if (\"api_key\" in json) {\n                const apikey = json.api_key;\n                TmpConfig_1.default.setApiKey(apikey);\n                this.dialogLogin.setLoginCondition(1);\n            }\n            if (\"debug_level\" in json) {\n                const debuglevel = json.debug_level;\n                TmpConfig_1.default.setDebugLevel(debuglevel);\n            }\n            if (\"auth_url\" in json) {\n                const authurl = json.auth_url;\n                TmpConfig_1.default.setAuthUrl(authurl);\n                if (authurl.length > 0) {\n                    this.dialogLogin.showPass();\n                }\n            }\n        });\n        this.paneMain = new paneMain_1.PaneMain();\n        this.paneFkey = new paneFkey_1.PaneFkey();\n        this.paneInput = new paneInput_1.PaneInput();\n        this.setInputEvents();\n        this.paneMonitor = new paneMonitor_1.PaneMonitor();\n        this.setMonitorEvents();\n        this.paneChat = new paneChat_1.PaneChat();\n        this.setChatEvents();\n        this.pftFileController = new fileController_1.default('pft-file-opener');\n        this.panePft = new panePft_1.PanePft();\n        this.setPftEvents();\n        this.panePftMon = new panePftMon_1.PanePftMon();\n        this.panes = {\n            \"i\": this.paneInput,\n            \"r\": this.paneChat,\n            \"p\": this.panePft,\n            \"f\": this.paneFkey,\n        };\n        this.localize();\n        this.setEvents();\n    } // end of constructor\n    // ==================== Sending ====================\n    sendMain(text) {\n        const dRaw = content_1.ContentUtil.makeDisplayData(text);\n        const d = this.comm.send_room(dRaw);\n        const dR = content_1.ContentClass.fromSendData(this.id, d);\n        this.paneMain.addNewItem(dR);\n    }\n    sendGross(lines) {\n        const text = lines.join('\\n');\n        const dRaw = content_1.ContentUtil.makeGrossData(text);\n        const d = this.comm.send_room(dRaw);\n        const dR = content_1.ContentClass.fromSendData(this.id, d);\n        this.paneMain.addNewGross(dR);\n    }\n    // ==================== Misc ====================\n    updateRoomName(room) {\n        this.roomName = room;\n        utilDom_1.UtilDom.setQuery(room);\n        if (room.length > 0) {\n            this.updatePageTitle(t_1.T.t(\"Room\", \"General\") + \" \" + room);\n        }\n        else {\n            this.updatePageTitle(t_1.T.t(\"Login\", \"Login\"));\n        }\n    }\n    updatePageTitle(title, atStart = true) {\n        if (this.pageTitle.length < 1) {\n            this.pageTitle = document.title;\n        }\n        if (atStart) {\n            document.title = title + \" - \" + this.pageTitle;\n        }\n        else {\n            document.title = this.pageTitle + \" - \" + title;\n        }\n    }\n    // ==================== Events ====================\n    setConfigDialogEvents() {\n        this.configFileController.onLoad = ev => {\n            var _a;\n            if (((_a = ev.target) === null || _a === void 0 ? void 0 : _a.result) == null)\n                return;\n            log_1.default.w('Info', 'Config opened.');\n            const text = ev.target.result; // this must be string\n            appConfig_1.AppConfig.trySetJSON(text);\n            this.reflectNewConfig();\n            this.dialogConfig.configToDialog(); // apply new config into config dialog\n            this.dialogConfigViewer.configToDialog(); // apply new config into config dialog\n        };\n        this.dialogConfig.setOnSet((names) => {\n            this.updateSomeConfigs(names);\n        });\n        this.dialogConfigViewer.setOnSet((names) => {\n            this.updateSomeConfigs(names);\n        });\n        this.dialogConfig.onResetClicked = () => {\n            appConfig_1.AppConfig.resetAll();\n            this.reflectNewConfig();\n            this.dialogConfig.configToDialog(); // apply initial config into config dialog\n            this.dialogConfigViewer.configToDialog(); // apply initial config into config dialog\n        };\n        this.dialogConfigViewer.onResetClicked = () => {\n            appConfig_1.AppConfig.resetAll();\n            this.reflectNewConfig();\n            this.dialogConfig.configToDialog(); // apply initial config into config dialog\n            this.dialogConfigViewer.configToDialog(); // apply initial config into config dialog\n        };\n        this.dialogConfig.onOpenClicked = () => {\n            this.configFileController.openDialogAndReadFile(appConfig_1.AppConfig.getExtensionMekikuWeb());\n        };\n        this.dialogConfigViewer.onOpenClicked = () => {\n            this.configFileController.openDialogAndReadFile(appConfig_1.AppConfig.getExtensionMekikuWeb());\n        };\n        this.dialogConfig.onSaveClicked = () => {\n            this.dialogInput.onOkClick = filename => {\n                fileController_1.Downloader.start(filename, appConfig_1.AppConfig.getJSON());\n            };\n            const label = t_1.T.t(\"file name\", \"General\");\n            const name = util_1.Util.getIsoStyleDateString() + appConfig_1.AppConfig.getExtensionMekikuWeb();\n            this.dialogInput.showDialog(label, name);\n        };\n        this.dialogConfigViewer.onSaveClicked = () => {\n            this.dialogInput.onOkClick = filename => {\n                fileController_1.Downloader.start(filename, appConfig_1.AppConfig.getJSON());\n            };\n            const label = t_1.T.t(\"file name\", \"General\");\n            const name = util_1.Util.getIsoStyleDateString() + appConfig_1.AppConfig.getExtensionMekikuWeb();\n            this.dialogInput.showDialog(label, name);\n        };\n        this.configFileController.onError = (ev, file) => {\n            var _a;\n            alert(`Error loading ${file.name} : ${(_a = ev.target) === null || _a === void 0 ? void 0 : _a.error}`);\n        };\n    }\n    setAppControlEvents() {\n        this.appControl.onLogout = () => {\n            this.comm.send_room(content_1.ContentUtil.makeLogoffData());\n            this.comm.leaveRoom();\n        };\n        this.appControl.onSetting = () => {\n            if (this.isViewer) {\n                this.dialogConfigViewer.showDialog();\n            }\n            else {\n                this.dialogConfig.showDialog();\n            }\n        };\n    }\n    setLoginDialogEvents() {\n        this.dialogLogin.onDownloadMain = () => {\n            const name = util_1.Util.getIsoModifiedDateTimeString() + \"_main.log\";\n            const log = this.paneMain.getMainLog().join(util_1.Util.getNewLineCode());\n            fileController_1.Downloader.start(name, log);\n        };\n        this.dialogLogin.onDownloadChat = () => {\n            const name = util_1.Util.getIsoModifiedDateTimeString() + \"_chat.log\";\n            const log = this.paneChat.getLog();\n            fileController_1.Downloader.start(name, log);\n        };\n        this.dialogLogin.onLoginClick = info => {\n            this.loginInfo = info;\n            if (info.room.length < 1) {\n                info.room = location.hash;\n            }\n            TmpConfig_1.default.setName(info.name);\n            TmpConfig_1.default.setMemberType(info.memberType);\n            let login_info = info;\n            this.comm.open(TmpConfig_1.default.getApiKey(), {\n                handleOpen: id => {\n                    this.comm.joinRoom(login_info);\n                },\n                debugLevel: TmpConfig_1.default.getDebugLevel()\n            });\n            this.updateRoomName(info.room);\n            // 'pass' is not used because no password\n            if (info.memberType === content_1.MemberType.WEB_VIEWER) {\n                this.setViewerStyle();\n            }\n            else {\n                this.setSubtitlerStyle();\n            }\n        };\n    }\n    setInputEvents() {\n        this.paneInput.setGetFkey((ix) => {\n            return this.paneFkey.getFKey(ix);\n        });\n        this.paneInput.setDoOnInput((text) => {\n            this.comm.queue_room(content_1.ContentUtil.makeMonitorData(text));\n        });\n        this.paneInput.setDoOnEnter((text) => {\n            this.sendMain(text);\n        });\n        this.paneInput.setDoOnUndo(() => {\n            const undoed = this.paneMain.undoLastItem();\n            if (undoed == null) {\n                return \"\";\n            }\n            const d = content_1.ContentUtil.makeUndoData(undoed.id, undoed.sentMsec);\n            this.comm.send_room(d);\n            return undoed.content;\n        });\n    }\n    setMonitorEvents() {\n        this.paneMonitor.setOnNewJoined(member => {\n            if (member.memberType === content_1.MemberType.WEB_SUBTITLER) {\n                this.paneChat.addSystemMessage(`(${t_1.T.t('login', 'Chat')} : ${member.name})`);\n            }\n            else {\n                this.paneChat.addSystemMessage(`(${t_1.T.t('New viewer joined.', 'Chat')})`);\n            }\n        });\n        this.paneMonitor.setOnLeft(member => {\n            if (member.memberType === content_1.MemberType.WEB_SUBTITLER) {\n                this.paneChat.addSystemMessage(`(${t_1.T.t('logout', 'Chat')} : ${member.name})`);\n            }\n            else {\n                this.paneChat.addSystemMessage(`(${t_1.T.t('A viewer left.', 'Chat')})`);\n            }\n        });\n    }\n    setChatEvents() {\n        this.paneChat.setGetFkey((ix) => {\n            return this.paneFkey.getFKey(ix);\n        });\n        this.paneChat.setOnSend((text) => {\n            this.comm.send_room(content_1.ContentUtil.makeChatData(text));\n            this.paneChat.addMessage(TmpConfig_1.default.getName(), text);\n        });\n    }\n    setPftEvents() {\n        // Events about PFT itself\n        this.panePft.setOnSend((text) => {\n            //this.comm.send_room(ContentUtil.makeDisplayData(text))\n            this.sendMain(text);\n        });\n        this.panePft.setOnGross((lines) => {\n            //this.comm.send_room(ContentUtil.makeGrossData(lines.join(\"\\n\")))\n            this.sendGross(lines);\n        });\n        this.panePft.setOnChange((aLines, bLines) => {\n            const a = aLines.join(\"\\n\");\n            const b = bLines.join(\"\\n\");\n            const data = this.comm.queue_room(content_1.ContentUtil.makePftMonData(a, b));\n            this.panePftMon.update(data.A, data.B, data);\n        });\n        this.panePft.setGetFkey((ix) => {\n            return this.paneFkey.getFKey(ix);\n        });\n        // Events about PFT file\n        this.panePft.setOnOpenCommand((i) => {\n            this.pftFileController.openDialogAndReadFile(\".mk8,.txt\");\n        });\n        this.panePft.setOnSaveCommand((text, name) => {\n            const label = t_1.T.t(\"file name\", \"General\");\n            this.dialogInput.onOkClick = (filename => {\n                this.panePft.NotifyPftSaved(filename);\n                fileController_1.Downloader.start(filename, text);\n            });\n            this.dialogInput.showDialog(label, name);\n        });\n        this.pftFileController.onLoad = (ev, file) => {\n            var _a;\n            if (((_a = ev.target) === null || _a === void 0 ? void 0 : _a.result) == null)\n                return;\n            const text = ev.target.result; // this must be string\n            this.panePft.NotifyPftOpened(text, file);\n        };\n        this.pftFileController.onError = (ev, file) => {\n            var _a;\n            alert(`Error loading ${file.name} : ${(_a = ev.target) === null || _a === void 0 ? void 0 : _a.error}`);\n        };\n    }\n    // ==================== Configurations ====================\n    reflectNewConfig() {\n        const locale = appConfig_1.AppConfig.data.getLocale();\n        log_1.default.w(\"Info\", `new config : locale=[${locale}]`);\n        t_1.T.setLocale(locale);\n        this.updateAllConfig();\n    }\n    setSubtitlerStyle() {\n        this.isViewer = false;\n        this.setSplits();\n        this.paneMain.setViewerMode(this.isViewer);\n        this.paneMain.updateConfig();\n        this.appControl.hideShortState();\n        this.paneContainer2.show();\n        this.paneContainer3.show();\n        this.paneContainer1.setDefault();\n        // TODO\n        this.paneInput.show();\n        this.paneMonitor.show();\n        this.appControl.goBottom();\n        this.paneInput.focus();\n    }\n    setViewerStyle() {\n        this.isViewer = true;\n        this.unsetSplits();\n        this.paneMain.setViewerMode(this.isViewer);\n        this.paneMain.updateConfig();\n        this.appControl.showShortState();\n        this.paneContainer2.hide();\n        this.paneContainer3.hide();\n        this.paneContainer1.setFullWidth();\n        this.paneInput.hide();\n        this.paneMonitor.hide();\n        this.appControl.goTop();\n    }\n    updateSomeConfigs(names) {\n        for (var name of names) {\n            log_1.default.w(\"Info\", `config updated [${name}]`);\n            switch (name) {\n                case \"misc\": {\n                    this.updateConfig();\n                    break;\n                }\n                case \"main\": {\n                    this.paneMain.updateConfig();\n                    break;\n                }\n                case \"input\": {\n                    this.paneInput.updateConfig();\n                    break;\n                }\n                case \"chat\": {\n                    this.paneChat.updateConfig();\n                    break;\n                }\n                case \"monitor\": {\n                    this.paneMonitor.updateConfig();\n                    break;\n                }\n                case \"pft\": {\n                    this.panePft.updateConfig();\n                    break;\n                }\n                case \"pftMon\": {\n                    this.panePftMon.updateConfig();\n                    break;\n                }\n                case \"fkey\": {\n                    this.paneFkey.updateConfig();\n                    break;\n                }\n            }\n        }\n    }\n    updateAllConfig() {\n        this.updateConfig();\n        this.paneMain.updateConfig();\n        this.paneInput.updateConfig();\n        this.paneChat.updateConfig();\n        this.paneMonitor.updateConfig();\n        this.panePft.updateConfig();\n        this.panePftMon.updateConfig();\n        this.paneFkey.updateConfig();\n    }\n    updateConfig() {\n        const locale = appConfig_1.AppConfig.data.getLocale();\n        t_1.T.setLocale(locale);\n        this.localizeAll();\n    }\n    setSplits() {\n        const gutterWidth = 6;\n        if (this.splitContainer == null) {\n            this.splitContainer = split_js_1.default(['#pane1', '#pane2', '#pane3'], {\n                sizes: [\n                    appConfig_1.AppConfig.data.misc_pane1_width,\n                    appConfig_1.AppConfig.data.misc_pane2_width,\n                    appConfig_1.AppConfig.data.misc_pane3_width,\n                ],\n                direction: 'horizontal',\n                gutterSize: gutterWidth,\n                onDragEnd: sizes => {\n                    appConfig_1.AppConfig.data.misc_pane1_width = sizes[0];\n                    appConfig_1.AppConfig.data.misc_pane2_width = sizes[1];\n                    appConfig_1.AppConfig.data.misc_pane3_width = sizes[2];\n                    this.paneMain.updateScreen();\n                },\n            });\n        }\n        else {\n            this.splitContainer.setSizes([\n                appConfig_1.AppConfig.data.misc_pane1_width,\n                appConfig_1.AppConfig.data.misc_pane2_width,\n                appConfig_1.AppConfig.data.misc_pane3_width,\n            ]);\n        }\n        if (this.splitDisplayMonitor == null) {\n            this.splitDisplayMonitor = split_js_1.default(['#display-input', '#monitor'], {\n                sizes: [\n                    appConfig_1.AppConfig.data.misc_display_input_height,\n                    appConfig_1.AppConfig.data.misc_monitor_height,\n                ],\n                direction: 'vertical',\n                gutterSize: gutterWidth,\n                onDragEnd: sizes => {\n                    appConfig_1.AppConfig.data.misc_display_input_height = sizes[0];\n                    appConfig_1.AppConfig.data.misc_monitor_height = sizes[1];\n                    this.paneMain.updateScreen();\n                },\n            });\n        }\n        else {\n            this.splitDisplayMonitor.setSizes([\n                appConfig_1.AppConfig.data.misc_display_input_height,\n                appConfig_1.AppConfig.data.misc_monitor_height,\n            ]);\n        }\n        if (this.splitPft == null) {\n            this.splitPft = split_js_1.default(['#pft', '#pftMon'], {\n                sizes: [\n                    appConfig_1.AppConfig.data.misc_pft_height,\n                    appConfig_1.AppConfig.data.misc_pftmon_height,\n                ],\n                direction: 'vertical',\n                gutterSize: gutterWidth,\n                onDragEnd: sizes => {\n                    appConfig_1.AppConfig.data.misc_pft_height = sizes[0];\n                    appConfig_1.AppConfig.data.misc_pftmon_height = sizes[1];\n                },\n            });\n        }\n        else {\n            this.splitPft.setSizes([\n                appConfig_1.AppConfig.data.misc_pft_height,\n                appConfig_1.AppConfig.data.misc_pftmon_height,\n            ]);\n        }\n    }\n    unsetSplits() {\n        if (this.splitContainer != null) {\n            this.splitContainer.destroy(true);\n            delete this.splitContainer;\n        }\n        if (this.splitDisplayMonitor != null) {\n            this.splitDisplayMonitor.destroy(true);\n            delete this.splitDisplayMonitor;\n        }\n        if (this.splitPft != null) {\n            this.splitPft.destroy(true);\n            delete this.splitPft;\n        }\n    }\n    localizeAll() {\n        this.localize();\n        this.paneInput.localize();\n        this.paneChat.localize();\n        this.paneMonitor.localize();\n        this.panePft.localize();\n        this.panePftMon.localize();\n        this.paneFkey.localize();\n    }\n    onPeerIdAcquired(id) {\n        this.id = id;\n    }\n    onJoined() {\n        this.paneMain.updateScreen(); // make sure update after CSS reflow finished\n        this.comm.send_room(content_1.ContentUtil.makeLoginData());\n    }\n    onLeft() {\n        if (this.dialogLogin == null)\n            return;\n        if (this.isErrorHandling)\n            return; // avoid during communication-error dialog appearing (after close it, this method is called)\n        if (this.dialogLogin.isShown())\n            return; // already shown\n        this.dialogLogin.setRoom(this.roomName);\n        this.dialogLogin.setName(TmpConfig_1.default.getName());\n        this.updateRoomName('');\n        const isSubtitler = TmpConfig_1.default.getMemberType() === content_1.MemberType.WEB_SUBTITLER;\n        const hasMain = this.paneMain.hasMainLog() && isSubtitler;\n        const hasChat = this.paneChat.hasLog() && isSubtitler;\n        this.dialogLogin.showDialog(hasMain, hasChat);\n    }\n    onSomeoneJoined(id) {\n        // nop\n    }\n    onSomeoneLeft(id) {\n        // you can catch leaving like operation (reload,etc.)\n        this.paneMonitor.deleteMember(id);\n    }\n    onReceived(data) {\n        const member = memberManager_1.MemberInfoClass.fromContent(data);\n        if (content_1.ContentType.LOGIN in data) {\n            this.comm.send_room(content_1.ContentUtil.makeResponseData());\n        }\n        if (content_1.ContentType.RESPONSE in data) {\n            // nop\n        }\n        if (content_1.ContentUtil.hasDisplayData(data)) {\n            const item = mekikuAnalyzer_1.MekikuUnitDataClass.fromContent(data);\n            item.contentType = content_1.ContentType.DISPLAY;\n            item.content = data.D;\n            this.paneMain.notifyNewItem(item);\n        }\n        if (content_1.ContentUtil.hasGrossData(data)) {\n            this.paneMain.addNewGross(data);\n        }\n        if (content_1.ContentUtil.hasUndoData(data)) {\n            this.paneMain.addNewUndo(data);\n        }\n        if (content_1.ContentType.HB in data) {\n        }\n        if (TmpConfig_1.default.getMemberType() === content_1.MemberType.WEB_SUBTITLER) {\n            if (content_1.ContentUtil.hasChatData(data)) {\n                this.paneChat.addMessage(data.senderName, data.C);\n            }\n            if (content_1.ContentUtil.hasMonitorData(data)) {\n                member.inputContent = data.M;\n            }\n            if (content_1.ContentUtil.hasPftMonData(data)) {\n                this.panePftMon.update(data.A, data.B, data);\n            }\n        }\n        if (content_1.ContentType.LOGOFF in data) {\n            this.paneMonitor.deleteMember(data.senderID);\n        }\n        else {\n            this.paneMonitor.updateMember(member, data);\n        }\n        this.paneMain.notifyNewItemsFinish();\n    }\n    onAuthError() {\n        // Show auth-error on login dialog\n        this.dialogNotify.onOkClick = () => {\n            this.onLeft();\n        };\n        this.dialogNotify.showDialog(t_1.T.t(\"Error\", \"General\"), t_1.T.t(\"Login failed.\", \"Login\"));\n    }\n    onCommunicationError(err) {\n        // Logout (if not done) and show notification dialog\n        this.isErrorHandling = true;\n        this.comm.leaveRoom();\n        this.dialogNotify.onOkClick = () => {\n            this.isErrorHandling = false;\n            this.onLeft();\n        };\n        const detail = (err.message != null)\n            ? \"\\n\" + t_1.T.t(\"Detail\", \"General\") + \" : \" + err.message\n            : \"\";\n        this.dialogNotify.showDialog(t_1.T.t(\"Error\", \"General\"), t_1.T.t(\"Communication error.\", \"General\") + detail);\n    }\n    onSomeError(err) {\n        // Logout (if not done) and show notification dialog\n        this.isErrorHandling = true;\n        this.comm.leaveRoom();\n        this.dialogNotify.onOkClick = () => {\n            this.isErrorHandling = false;\n            this.onLeft();\n        };\n        const detail = (err.message != null)\n            ? \"\\n\" + t_1.T.t(\"Detail\", \"General\") + \" : \" + err.message\n            : \"\";\n        this.dialogNotify.showDialog(t_1.T.t(\"Error\", \"General\"), t_1.T.t(\"Communication error.\", \"General\") + detail);\n    }\n    onPeerError(err) {\n        if (err.type === \"authentication\") {\n            this.onAuthError();\n        }\n        else if (err.type === \"socket-error\") {\n            this.onCommunicationError(err);\n        }\n        else {\n            this.onSomeError(err);\n        }\n    }\n    makeCommEventHandlers() {\n        const r = new mekikuComm_1.MekikuCommEvents();\n        r.onPeerIdAcquired = (id) => { this.onPeerIdAcquired(id); };\n        r.onPeerError = (err) => { this.onPeerError(err); };\n        r.onJoinedRoom = () => { this.onJoined(); };\n        r.onLeftRoom = () => { this.onLeft(); };\n        r.onReceived = (data) => { this.onReceived(data); };\n        r.onSomeoneJoined = (id) => { this.onSomeoneJoined(id); };\n        r.onSomeoneLeft = (id) => { this.onSomeoneLeft(id); };\n        r.logger = (msg) => { log_1.default.w(\"Comm\", msg); };\n        return r;\n    }\n    onBeforeUnload(ev) {\n        var _a;\n        if (((_a = this.comm) === null || _a === void 0 ? void 0 : _a.isInRoom()) === true) {\n            // if in room, confirm if unload is of intention\n            ev.preventDefault();\n            ev.returnValue = \"Truly exit?\"; // these literals are not used by browsers\n            return \"Truly exit?\";\n        }\n    }\n    onUnload(ev) {\n        var _a;\n        if (((_a = this.comm) === null || _a === void 0 ? void 0 : _a.isInRoom()) === true) {\n            this.comm.send_room(content_1.ContentUtil.makeLogoffData());\n            this.comm.leaveRoom();\n        }\n        const config = appConfig_1.AppConfig.getJSON();\n        localStorage.setItem('config', config);\n    }\n    setEvents() {\n        window.addEventListener('resize', ev => {\n            this.paneMain.updateScreen();\n        });\n        document.addEventListener('keydown', ev => {\n            // no F5 reload when logged in\n            if (ev.key === \"F5\" && this.comm.isInRoom()) {\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n                ev.stopPropagation();\n            }\n            // no F1 reload when logged in\n            if (ev.key === \"F1\" && this.comm.isInRoom()) {\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n                ev.stopPropagation();\n            }\n            // shortcuts\n            const ifCmdOrCtrlOnly = utilDom_1.UtilDom.isCommandOrControlPressed(ev) && (!ev.shiftKey);\n            if (ifCmdOrCtrlOnly) {\n                const key = ev.key.toLowerCase();\n                if (key in this.panes) {\n                    this.panes[key].focus();\n                    ev.preventDefault();\n                    ev.stopImmediatePropagation();\n                    ev.stopPropagation();\n                }\n            }\n            if (ev.key === \"o\" && ifCmdOrCtrlOnly) {\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n                ev.stopPropagation();\n                // open config open dialog\n            }\n            if (ev.key === \"s\" && ifCmdOrCtrlOnly) {\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n                ev.stopPropagation();\n                // download config open dialog\n            }\n        });\n    }\n    localize() {\n        const targets = document.getElementsByClassName(\"l10n\");\n        for (const target of targets) {\n            const id = target.id;\n            const el = document.getElementById(id);\n            if (el === null)\n                continue;\n            // l10n-items should have textContent in base language (English).\n            // First time, text(English) is copied to \"data-key\" attribute (not written in HTML)\n            // Later, \"data-key\" is used as key for l10n.\n            const key1 = el.dataset[\"key\"];\n            const key2 = el.textContent;\n            var base;\n            if (key1 != null) {\n                base = key1;\n            }\n            else if (key2 != null) {\n                base = key2;\n                el.dataset[\"key\"] = base;\n            }\n            else {\n                log_1.default.w('Warning', `app.localize element[${id}] no textContent.`);\n                continue;\n            }\n            const context = el.dataset[\"context\"];\n            if (context === undefined) {\n                log_1.default.w('Warning', `app.localize element[${id}] data-context not exists.`);\n                continue;\n            }\n            const phrase = t_1.T.t(base, context);\n            el.textContent = phrase;\n        }\n        const targetsTitle = document.getElementsByClassName(\"title-l10n\");\n        for (const target of targetsTitle) {\n            const id = target.id;\n            const el = document.getElementById(id);\n            if (el === null)\n                continue;\n            const base = el.title;\n            if (base === null)\n                continue;\n            const context = el.dataset[\"context\"];\n            if (context === undefined)\n                continue;\n            const phrase = t_1.T.t(base, context);\n            el.title = phrase;\n        }\n    }\n}\nexports.default = App;\n\n\n//# sourceURL=webpack:///./src/app.ts?");

/***/ }),

/***/ "./src/appConfig.ts":
/*!**************************!*\
  !*** ./src/appConfig.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AppConfig = void 0;\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nclass AppConfig {\n    // singleton\n    constructor() {\n        // miscellaneous\n        this._misc_locale = \"\"; // access through getLocale/setLocale.\n        this.misc_pane1_width = 45;\n        this.misc_pane2_width = 25;\n        this.misc_pane3_width = 30;\n        this.misc_display_input_height = 65;\n        this.misc_monitor_height = 35;\n        this.misc_pft_height = 50;\n        this.misc_pftmon_height = 50;\n        // display pane\n        this.main_font_familyName = \"\";\n        this.main_font_size = 24;\n        this.main_font_isBold = false;\n        this.main_foreColor = \"#ffffff\";\n        this.main_backColor = \"#000000\";\n        this.main_outline_enabled = false;\n        this.main_outline_color = \"#80ff80\";\n        this.main_outline_width = 2;\n        this.main_scrollMsec = 200; // [msec]\n        this.main_lineHeight = 140; // [%]\n        // display pane (viewer mode)\n        this.main_v_font_familyName = \"\";\n        this.main_v_font_size = 42;\n        this.main_v_font_isBold = false;\n        this.main_v_foreColor = \"#ffffff\";\n        this.main_v_backColor = \"#000000\";\n        this.main_v_outline_enabled = false;\n        this.main_v_outline_color = \"#80ff80\";\n        this.main_v_outline_width = 2;\n        this.main_v_scrollMsec = 200; // [msec]\n        this.main_v_lineHeight = 140; // [%]\n        // input pane\n        this.input_font_familyName = \"\";\n        this.input_font_size = 14;\n        this.input_font_isBold = false;\n        this.input_foreColor = \"#000000\";\n        this.input_backColor = \"#ffffff\";\n        this.input_parentheses_1 = \"\";\n        this.input_parentheses_2 = \"\";\n        this.input_parenthesesShift_1 = \"\";\n        this.input_parenthesesShift_2 = \"\";\n        // chat pane\n        this.chat_font_familyName = \"\";\n        this.chat_font_size = 12;\n        this.chat_font_isBold = false;\n        this.chat_foreColor = \"#ffffff\";\n        this.chat_backColor = \"#000000\";\n        this.chat_notifyColor = \"#ff0000\";\n        this.chat_timer = 5;\n        // monitor pane\n        this.monitor_font_familyName = \"\";\n        this.monitor_font_size = 10;\n        this.monitor_font_isBold = false;\n        this.monitor_foreColor = \"#ffffff\";\n        this.monitor_backColor = \"#000000\";\n        // pft pane\n        this.pft_font_familyName = \"\";\n        this.pft_font_size = 12;\n        this.pft_font_isBold = false;\n        this.pft_foreColor = \"#ffffff\";\n        this.pft_backColor = \"#000000\";\n        this.pft_nameBackColor = \"#000000\";\n        this.pft_nameOtherBackColor = \"#333333\";\n        this.pft_show_isAll = true;\n        this.pft_show_active_ratio = 100;\n        this.pft_fallbackEncoding = \"Shift-JIS\";\n        // pft-monitor pane\n        this.pftMon_font_familyName = \"\";\n        this.pftMon_font_size = 12;\n        this.pftMon_font_isBold = false;\n        this.pftMon_foreColor = \"#ffffff\";\n        this.pftMon_backColor = \"#000000\";\n        // f-keys pane\n        this.fkey_font_familyName = \"\";\n        this.fkey_font_size = 10;\n        this.fkey_font_isBold = false;\n        this.fkey_foreColor = \"#ffffff\";\n        this.fkey_backColor = \"#000000\";\n    }\n    // empty string : use OS default locale\n    getLocale() {\n        return (this._misc_locale === \"\") ? t_1.T.getBrowserLocale() : this._misc_locale;\n    }\n    setLocale(locale) {\n        if (locale === t_1.T.getBrowserLocale()) {\n            this._misc_locale = \"\";\n        }\n        else {\n            this._misc_locale = locale;\n        }\n    }\n    getParentheses1_Default() { return t_1.T.t(\"\", \"Config|Input\"); }\n    getParentheses2_Default() { return t_1.T.t(\"\", \"Config|Input\"); }\n    getParenthesesShift1_Default() { return t_1.T.t(\"(\", \"Config|Input\"); }\n    getParenthesesShift2_Default() { return t_1.T.t(\")\", \"Config|Input\"); }\n    getParentheses1() {\n        if (this.input_parentheses_1 === \"\")\n            return this.getParentheses1_Default();\n        return this.input_parentheses_1;\n    }\n    setParentheses1(p) {\n        if (p === this.getParentheses1_Default()) {\n            if (this.input_parentheses_1 === \"\")\n                return false;\n            this.input_parentheses_1 = \"\";\n        }\n        else {\n            if (this.input_parentheses_1 === p)\n                return false;\n            this.input_parentheses_1 = p;\n        }\n        return true;\n    }\n    getParentheses2() {\n        if (this.input_parentheses_2 === \"\")\n            return this.getParentheses2_Default();\n        return this.input_parentheses_2;\n    }\n    setParentheses2(p) {\n        if (p === this.getParentheses2_Default()) {\n            if (this.input_parentheses_2 === \"\")\n                return false;\n            this.input_parentheses_2 = \"\";\n        }\n        else {\n            if (this.input_parentheses_2 === p)\n                return false;\n            this.input_parentheses_2 = p;\n        }\n        return true;\n    }\n    getParenthesesShift1() {\n        if (this.input_parenthesesShift_1 === \"\")\n            return this.getParenthesesShift1_Default();\n        return this.input_parenthesesShift_1;\n    }\n    setParenthesesShift1(p) {\n        if (p === this.getParenthesesShift1_Default()) {\n            if (this.input_parenthesesShift_1 === \"\")\n                return false;\n            this.input_parenthesesShift_1 = \"\";\n        }\n        else {\n            if (this.input_parenthesesShift_1 === p)\n                return false;\n            this.input_parenthesesShift_1 = p;\n        }\n        return true;\n    }\n    getParenthesesShift2() {\n        if (this.input_parenthesesShift_2 === \"\")\n            return this.getParenthesesShift2_Default();\n        return this.input_parenthesesShift_2;\n    }\n    setParenthesesShift2(p) {\n        if (p === this.getParenthesesShift2_Default()) {\n            if (this.input_parenthesesShift_2 === \"\")\n                return false;\n            this.input_parenthesesShift_2 = \"\";\n        }\n        else {\n            if (this.input_parenthesesShift_2 === p)\n                return false;\n            this.input_parenthesesShift_2 = p;\n        }\n        return true;\n    }\n    /**\n     * Limit the value of pft_show_active_ratio only in [100,150,200,300].\n     */\n    limitPftShowActiveRatio() {\n        if (this.pft_show_active_ratio < 125) {\n            this.pft_show_active_ratio = 100;\n        }\n        else if (this.pft_show_active_ratio < 175) {\n            this.pft_show_active_ratio = 150;\n        }\n        else if (this.pft_show_active_ratio < 250) {\n            this.pft_show_active_ratio = 200;\n        }\n        else {\n            this.pft_show_active_ratio = 300;\n        }\n    }\n    static get data() {\n        if (AppConfig.configNow === undefined) {\n            AppConfig.configNow = new AppConfig();\n        }\n        return AppConfig.configNow;\n    }\n    // utilities\n    /**\n     * returns config file extension (dot included)\n     */\n    static getExtensionMekikuWeb() {\n        return '.mkw';\n    }\n    // set values\n    static tryApplyNewData(loaded) {\n        this.configNow = new AppConfig();\n        for (var key of Object.keys(loaded)) {\n            if (key in this.configNow) {\n                if (typeof this.configNow[key] === typeof loaded[key]) {\n                    this.configNow[key] = loaded[key];\n                }\n            }\n        }\n        return true;\n    }\n    static trySetJSON(json) {\n        const obj = JSON.parse(json);\n        return this.tryApplyNewData(obj);\n    }\n    static getJSON() {\n        return JSON.stringify(AppConfig.data);\n    }\n    static resetAll() {\n        AppConfig.configNow = new AppConfig();\n    }\n}\nexports.AppConfig = AppConfig;\nAppConfig.configNow = undefined;\n\n\n//# sourceURL=webpack:///./src/appConfig.ts?");

/***/ }),

/***/ "./src/appControlPane.ts":
/*!*******************************!*\
  !*** ./src/appControlPane.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass AppControlPane {\n    constructor() {\n        this.control = document.getElementById('app_control');\n        this.shortState = document.getElementById('short_state');\n        this.setting = document.getElementById('appSetting');\n        this.logout = document.getElementById('appLogout');\n        this.onSetting = () => { };\n        this.onLogout = () => { };\n        this.setting.addEventListener('click', (ev) => {\n            this.onSetting();\n        });\n        this.logout.addEventListener('click', (ev) => {\n            this.onLogout();\n        });\n    }\n    goTop() {\n        this.control.classList.remove('bottom');\n        this.control.classList.add('top');\n    }\n    goBottom() {\n        this.control.classList.remove('top');\n        this.control.classList.add('bottom');\n    }\n    showShortState() {\n        utilDom_1.UtilDom.displayOn(this.shortState);\n    }\n    hideShortState() {\n        utilDom_1.UtilDom.displayOff(this.shortState);\n    }\n}\nexports.default = AppControlPane;\n\n\n//# sourceURL=webpack:///./src/appControlPane.ts?");

/***/ }),

/***/ "./src/content.ts":
/*!************************!*\
  !*** ./src/content.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContentType = exports.MemberType = exports.ContentUtil = exports.ContentClass = exports.ContentToSendClass = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nclass ContentToSendClass {\n    constructor(name, type) {\n        this.seqCount = ++ContentToSendClass.counter;\n        this.sendTimeCount = Date.now();\n        this.senderName = name;\n        this.memberType = type;\n    }\n}\nexports.ContentToSendClass = ContentToSendClass;\nContentToSendClass.counter = 0;\n/**\n * Data-storage class (similar to UdpContent of mekiku-web)\n */\nclass ContentClass {\n    constructor(mType) {\n        this.seqCount = 0;\n        this.sendTimeCount = 0;\n        this.senderName = \"\";\n        this.memberType = exports.MemberType.WEB_SUBTITLER;\n        this.receiveTimeCount = 0;\n        this.senderID = \"\";\n        this.sendTimeCount = Date.now();\n        this.memberType = mType;\n    }\n    /**\n     * Creating \"Content\" class object from received data\n     * @param id id of the sender\n     * @param val data received\n     */\n    static fromAny(id, val) {\n        if (val == null)\n            return null;\n        if (!util_1.Util.isNumber(val.seqCount))\n            return null;\n        if (!util_1.Util.isNumber(val.sendTimeCount))\n            return null;\n        if (!util_1.Util.isString(val.memberType))\n            return null;\n        if (!util_1.Util.isString(val.senderName))\n            return null;\n        val.receiveTimeCount = Date.now();\n        val.senderID = id;\n        const d = val;\n        return d;\n    }\n    static fromSendData(id, d) {\n        const r = d;\n        r.senderID = id;\n        r.receiveTimeCount = d.sendTimeCount;\n        return r;\n    }\n}\nexports.ContentClass = ContentClass;\nclass ContentUtil {\n    static makeLoginData() {\n        return { \"L\": \"\" };\n    }\n    static makeResponseData() {\n        return { \"R\": \"\" };\n    }\n    static makeDisplayData(text) {\n        return {\n            \"D\": text,\n            \"M\": \"\",\n        };\n    }\n    /**\n     * Check if parameter has \"display\" data or not.\n     * Necessary for accessing \"d.D\" value in TypeScript.\n     * https://qiita.com/ma2saka/items/eb2d26236c20afb7f764\n     * @param d any object\n     * @returns boolean (true if the parameter has \"display\" data)\n     */\n    static hasDisplayData(d) {\n        if (!d)\n            return false;\n        if (d.D && typeof d.D === 'string')\n            return true;\n        return false;\n    }\n    static makeGrossData(text) {\n        return {\n            \"G\": text,\n        };\n    }\n    static hasGrossData(d) {\n        if (!d)\n            return false;\n        if (d.G && typeof d.G === 'string')\n            return true;\n        return false;\n    }\n    static makeChatData(text) {\n        return {\n            \"C\": text\n        };\n    }\n    static hasChatData(d) {\n        if (!d)\n            return false;\n        if (d.C && typeof d.C === 'string')\n            return true;\n        return false;\n    }\n    static makeMonitorData(text) {\n        return {\n            \"M\": text\n        };\n    }\n    static hasMonitorData(d) {\n        if (!d)\n            return false;\n        if (d.M != null && typeof d.M === 'string')\n            return true;\n        return false;\n    }\n    static makePftMonData(above, below) {\n        return {\n            \"A\": above,\n            \"B\": below,\n        };\n    }\n    static hasPftMonData(d) {\n        if (!d)\n            return false;\n        if (d.A != null && d.B != null && typeof d.A === 'string' && typeof d.B === 'string')\n            return true;\n        return false;\n    }\n    static makeUndoData(id, sendTime) {\n        return {\n            \"U_ID\": id,\n            \"U_SENDTIME\": sendTime\n        };\n    }\n    static hasUndoData(d) {\n        if (!d)\n            return false;\n        if (d.U_ID && d.U_SENDTIME\n            && typeof d.U_ID === 'string'\n            && typeof d.U_SENDTIME === 'number')\n            return true;\n        return false;\n    }\n    static makeLogoffData() {\n        return { \"F\": \"\" };\n    }\n}\nexports.ContentUtil = ContentUtil;\nexports.MemberType = {\n    WEB_SUBTITLER: \"wi\",\n    WEB_VIEWER: \"wv\",\n};\nexports.ContentType = {\n    LOGIN: \"L\",\n    RESPONSE: \"R\",\n    DISPLAY: \"D\",\n    GROSS: \"G\",\n    CHAT: \"C\",\n    MONITOR: \"M\",\n    PFT_ABOVE: \"A\",\n    PFT_BELOW: \"B\",\n    UNDO_ID: \"U_ID\",\n    UNDO_SENDTIME: \"U_SENDTIME\",\n    ERASE: \"E\",\n    LOGOFF: \"F\",\n    HB: \"H\",\n};\n\n\n//# sourceURL=webpack:///./src/content.ts?");

/***/ }),

/***/ "./src/contentManager.ts":
/*!*******************************!*\
  !*** ./src/contentManager.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MainUpdateFlags = exports.EstimateResult = exports.DisplayLinesClass = exports.ContentManager = void 0;\nconst mekikuAnalyzer_1 = __webpack_require__(/*! ./mekikuAnalyzer */ \"./src/mekikuAnalyzer.ts\");\nconst content_1 = __webpack_require__(/*! ./content */ \"./src/content.ts\");\n/**\n * Manages main-display content.\n * assumed usage : instance in PaneMain (needs interactions with PaneMain)\n */\nclass ContentManager {\n    constructor() {\n        this.MIN_D_MSEC_IN_SAME_ID = -20000;\n        this.MAX_LOG_SCAN = 50;\n        this.MAX_UNDO = 5;\n        this.loginMsec = Date.now();\n        /**\n         * Storage of main-display-items (type:D,G,E).\n         * (Undo items are not stored,\n         *  but undone items remains with flag of MekikuUnitDataFlags.UNDONE)\n         */\n        this.log = new Array();\n        this.updateFlags = 0;\n        this.indexToAdd = 0;\n        // ---------- ---------- Log Handling ---------- ----------\n        /** Log position displayed at the top of main pane */\n        this.top = new LogPosition();\n    }\n    setLoginMsec(t) {\n        this.loginMsec = t;\n    }\n    getUpdateFlags() { return this.updateFlags; }\n    /**\n     * Proceed top line.\n     * @param n number of line to proceed (default : 1)\n     * @returns true if \"cannot proceed because already at last\" occurs\n     */\n    proceedLine(n = 1) {\n        const res = this.proceedPosition(this.top, n);\n        return res;\n    }\n    /**\n     * proceed LogPosition\n     * @returns true if \"cannot proceed because already at last\" occurs\n     */\n    proceedPosition(p, n) {\n        var result = false;\n        if (this.ignoreUndoneLogs(p) === true) {\n            result = true;\n        }\n        else {\n            for (var i = 0; i < n; i++) {\n                if (this.isLineAtLastInThisLog(p)) {\n                    if (this.isLogItemAtLast(p)) {\n                        result = true;\n                        break;\n                    }\n                    p.log++;\n                    p.line = 0;\n                    if (this.ignoreUndoneLogs(p) === true) {\n                        result = true;\n                        break;\n                    }\n                }\n                else {\n                    p.line++; // same log, next line\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * if current log-item is undone, proceed to next available log.\n     * @param p position from where check begins\n     * @returns true if all items from current one are all undone\n     */\n    ignoreUndoneLogs(p) {\n        var result = false;\n        while (this.isUndone(this.log[p.log])) {\n            if (this.isLogItemAtLast(p)) {\n                result = true;\n                break;\n            }\n            p.log++;\n            p.line = 0;\n        }\n        return result;\n    }\n    isLogItemAtLast(p) {\n        return (p.log >= (this.log.length - 1));\n    }\n    isLineAtLastInThisLog(p) {\n        return (p.line >= (this.log[p.log].lines.length - 1));\n    }\n    isLogLineAtLast(p) {\n        return (this.isLogItemAtLast(p) && this.isLineAtLastInThisLog(p));\n    }\n    getDisplayLog() {\n        let result = new Array();\n        if (this.log.length < 1)\n            return result;\n        let pos = LogPosition.clone(this.top);\n        while (true) {\n            if (this.ignoreUndoneLogs(pos)) {\n                break;\n            }\n            else {\n                result.push(this.log[pos.log].lines[pos.line]);\n                if (this.proceedPosition(pos, 1)) {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n    // ---------- ---------- Log Handling END ---------- ----------\n    getComplements(n) {\n        const len = this.log.length;\n        const iBegin = len - 1;\n        const iEnd = Math.max(iBegin - n + 1, 0);\n        var result = [];\n        for (var ix = iBegin; ix >= iEnd; ix--) {\n            if (this.log[ix].estimatedRecvMsec < this.loginMsec) {\n                break; // cut before login\n            }\n            result.push(this.log[ix]);\n        }\n        return result;\n    }\n    hasLog() {\n        return this.log.length > 0;\n    }\n    getLog() {\n        return this.log\n            .filter((value, index, array) => {\n            return (value.flag & mekikuAnalyzer_1.MekikuUnitDataFlags.UNDONE) === 0;\n        })\n            .map((value, index, array) => {\n            return value.content;\n        });\n    }\n    /**\n     * scan items in the log (range of newly added or restructuring) and update lineBegin and lineEnd\n     * @param callback function to handle items\n     */\n    loopItems(callback) {\n        if (this.updateFlags === 0)\n            return;\n        const rFlags = MainUpdateFlags.ERASE | MainUpdateFlags.GROSS | MainUpdateFlags.INBETWEEN | MainUpdateFlags.UNDO;\n        const restructure = (this.updateFlags & rFlags) !== 0;\n        const ixBegin = restructure ? this.top.log : this.indexToAdd;\n        this.doLoopItems(ixBegin, (d) => { return callback(d); });\n    }\n    /**\n     * scan from top-of-display item in the log and update lineBegin and lineEnd\n     * @param callback function to handle items\n     */\n    loopItemsFromTop(callback) {\n        this.doLoopItems(this.top.log, (d) => { return callback(d); });\n    }\n    /**\n     * scan items in the log\n     * @param ixBegin starting index in the log\n     * @param callback function to handle items, must return divided lines\n     */\n    doLoopItems(ixBegin, callback) {\n        const len = this.log.length;\n        for (var ix = ixBegin; ix < len; ix++) {\n            if (this.isUndone(this.log[ix]))\n                continue;\n            this.log[ix].lines = callback(this.log[ix]);\n        }\n    }\n    undoLastItem() {\n        const len = this.log.length;\n        const min = Math.max(len - this.MAX_UNDO, 0);\n        for (var ix = (len - 1); ix >= min; ix--) {\n            if (this.log[ix].contentType === content_1.ContentType.ERASE\n                || this.log[ix].contentType === content_1.ContentType.GROSS) {\n                break; // cannot undo Gross, Erase and anything before Gross and Erase.\n            }\n            if (this.isNotUndone(this.log[ix])) {\n                this.log[ix].flag |= mekikuAnalyzer_1.MekikuUnitDataFlags.UNDONE;\n                this.updateFlags |= MainUpdateFlags.CHANGE | MainUpdateFlags.UNDO;\n                return this.log[ix];\n            }\n        }\n        return null;\n    }\n    /**\n     * Try undo item in the log\n     * @param id id of the sender\n     * @param sentMsec time when the item is sent\n     * @returns true(undo-ed successfully) false(already undo-ed) null(not found)\n     */\n    undoItem(id, sentMsec) {\n        const len = this.log.length;\n        const min = Math.max(len - this.MAX_LOG_SCAN, 0);\n        for (var ix = (len - 1); ix >= min; ix--) {\n            if (this.log[ix].id === id && this.log[ix].sentMsec === sentMsec) {\n                if (this.isNotUndone(this.log[ix])) {\n                    this.log[ix].flag |= mekikuAnalyzer_1.MekikuUnitDataFlags.UNDONE;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * notify the end of one packet (main and possibly complements).\n     */\n    notifyPacketEnd() {\n        this.updateFlags = 0;\n        this.indexToAdd = this.log.length;\n    }\n    /**\n     * add new data (received) into instance property.\n     * supported content-types : D,G,E,U\n     * @param newData data to add\n     */\n    updateLog(newData) {\n        const r = this.doUpdateLog(newData);\n        this.updateFlags |= r;\n        return r;\n    }\n    doUpdateLog(newData) {\n        const baseFlag = this.MakeBaseFlag(newData);\n        // RLog.w(`ContentManager.doUpdateLog : data ${newData.contentType}:[${newData.content}] base:[${baseFlag}]`)\n        // reject if content type is out of scope.\n        if (baseFlag === MainUpdateFlags.NOP) {\n            return MainUpdateFlags.NOP;\n        }\n        // undo\n        // TODO: yet implemented\n        // make cache parameters\n        const newDataForEstimate = new mekikuAnalyzer_1.MekikuUnitDataForEstimate(newData);\n        // reject too old (before login) data\n        if (newDataForEstimate.estimatedRecvMsec < this.loginMsec) {\n            // RLog.w(`too old (newdata[${newDataForEstimate.estimatedRecvMsec}] , login[${TmpConfig.I.login_time}])`); \n            return MainUpdateFlags.NOP;\n        }\n        const estimate = this.scanLog(newDataForEstimate);\n        if (estimate.result === EstimateResult.ADD) {\n            // Log.w('Info',`result:add`)\n            this.log.push(newDataForEstimate);\n            return baseFlag;\n        }\n        else if (estimate.result === EstimateResult.INSERT) {\n            // Log.w('Info',`result:insert at ${estimate.iInsert}`)\n            this.log.splice(estimate.iInsert, 0, newDataForEstimate);\n            return baseFlag | MainUpdateFlags.INBETWEEN;\n        }\n        else if (estimate.result === EstimateResult.UPDATE) {\n            if (this.isNotUndone(this.log[estimate.iInsert])\n                && this.isUndone(newDataForEstimate)\n                && ((baseFlag & (MainUpdateFlags.ERASE | MainUpdateFlags.GROSS)) == 0)) {\n                // Log.w('Info',`result:undo at ${estimate.iInsert}`)\n                this.log[estimate.iInsert].flag = mekikuAnalyzer_1.MekikuUnitDataFlags.UNDONE;\n                return MainUpdateFlags.CHANGE | MainUpdateFlags.INBETWEEN | MainUpdateFlags.UNDO;\n            }\n            else {\n                // Log.w('Info',`result:update...nothing at ${estimate.iInsert}`)\n                return MainUpdateFlags.NOP;\n            }\n        }\n        else {\n            // Log.w('Info',`result:${estimate.result}`)\n            return MainUpdateFlags.NOP;\n        }\n    }\n    /**\n     * add new data. for use \"send by myself\".\n     * supported content-types : D,G,E\n     * @param newData data to add\n     */\n    addLog(newData) {\n        const baseFlag = this.MakeBaseFlag(newData);\n        if (baseFlag === MainUpdateFlags.NOP) {\n            return baseFlag;\n        }\n        const newDataForEstimate = new mekikuAnalyzer_1.MekikuUnitDataForEstimate(newData);\n        this.log.push(newDataForEstimate);\n        this.updateFlags |= baseFlag;\n        return baseFlag;\n    }\n    isUndone(data) {\n        return (data.flag & mekikuAnalyzer_1.MekikuUnitDataFlags.UNDONE) !== 0;\n    }\n    isNotUndone(data) {\n        return (data.flag & mekikuAnalyzer_1.MekikuUnitDataFlags.UNDONE) === 0;\n    }\n    MakeBaseFlag(newData) {\n        if (newData.contentType == content_1.ContentType.ERASE) {\n            return MainUpdateFlags.CHANGE | MainUpdateFlags.ERASE;\n        }\n        if (newData.contentType == content_1.ContentType.GROSS) {\n            return MainUpdateFlags.CHANGE | MainUpdateFlags.GROSS;\n        }\n        if (newData.contentType == content_1.ContentType.UNDO_ID) {\n            return MainUpdateFlags.CHANGE | MainUpdateFlags.UNDO;\n        }\n        if (newData.contentType == content_1.ContentType.DISPLAY) {\n            return MainUpdateFlags.CHANGE;\n        }\n        return MainUpdateFlags.NOP;\n    }\n    scanLog(newData) {\n        //RLog.w(`scanLog begins`)\n        let r = new RangeEstimation();\n        const len = this.log.length;\n        if (len < 1) {\n            r.result = EstimateResult.ADD;\n            return r;\n        }\n        const ixMax = this.log.length - 1;\n        const ixMin = Math.max(ixMax - this.MAX_LOG_SCAN, 0);\n        //RLog.w(`scan range:[${ixMin}:${ixMax}]`)\n        for (var ix = ixMax; ix >= ixMin; ix--) {\n            const logItem = this.log[ix];\n            if (logItem.id === newData.id) {\n                // from same IP\n                if (logItem.sentTimeAnyway === newData.sentTimeAnyway) {\n                    r.result = EstimateResult.UPDATE;\n                    r.iInsert = ix;\n                    return r;\n                }\n                else if (logItem.sentTimeAnyway < newData.sentTimeAnyway) {\n                    r.iSameIpFirst = ix + 1;\n                    break;\n                }\n                else if (logItem.receivedMsec - newData.receivedMsec >= this.MIN_D_MSEC_IN_SAME_ID) {\n                    r.iSameIpLast = ix;\n                }\n            }\n            else {\n                // from other IP\n                if (logItem.estimatedRecvMsec <= newData.estimatedRecvMsec) {\n                    if (r.iOtherIpFirst === -1) {\n                        r.iOtherIpFirst = ix + 1;\n                    }\n                }\n                else {\n                    if (r.iOtherIpFirst === -1) {\n                        r.iOtherIpLast = ix;\n                    }\n                }\n            }\n        }\n        if (r.iSameIpLast < r.iOtherIpFirst) {\n            r.iInsert = r.iSameIpLast;\n        }\n        else if (r.iSameIpFirst > r.iOtherIpLast) {\n            r.iInsert = r.iSameIpFirst;\n        }\n        else {\n            r.iInsert = Math.max(Math.max(r.iSameIpFirst, r.iOtherIpFirst), Math.min(r.iSameIpLast, r.iOtherIpLast));\n        }\n        if (r.iInsert >= len) {\n            r.result = EstimateResult.ADD;\n        }\n        else if (r.iSameIpFirst === -1 && r.iOtherIpFirst === -1 && len > 0) {\n            r.result = EstimateResult.UNIDENTIFIED;\n        }\n        else {\n            r.result = EstimateResult.INSERT;\n        }\n        // RLog.w(`result ${r.toString()}`)\n        return r;\n    }\n}\nexports.ContentManager = ContentManager;\nclass LogPosition {\n    constructor(log = 0, line = 0) {\n        this.log = 0;\n        this.line = 0;\n        this.log = log;\n        this.line = line;\n    }\n    static clone(p) {\n        return new LogPosition(p.log, p.line);\n    }\n}\nclass DisplayLinesClass {\n    constructor(begin, end, lines) {\n        this.lineBegin = begin;\n        this.lineEnd = end;\n        this.lines = lines;\n    }\n}\nexports.DisplayLinesClass = DisplayLinesClass;\nclass RangeEstimation {\n    constructor() {\n        this.iInsert = Number.MAX_SAFE_INTEGER;\n        this.iSameIpFirst = -1;\n        this.iSameIpLast = Number.MAX_SAFE_INTEGER;\n        this.iOtherIpFirst = -1;\n        this.iOtherIpLast = Number.MAX_SAFE_INTEGER;\n    }\n    toString() {\n        return `[${this.result}] same[${this.iSameIpFirst}:${this.iSameIpLast}] other[${this.iOtherIpFirst}:${this.iOtherIpLast}]`;\n    }\n}\nvar EstimateResult;\n(function (EstimateResult) {\n    EstimateResult[EstimateResult[\"NOP\"] = 0] = \"NOP\";\n    EstimateResult[EstimateResult[\"ADD\"] = 1] = \"ADD\";\n    EstimateResult[EstimateResult[\"INSERT\"] = 2] = \"INSERT\";\n    EstimateResult[EstimateResult[\"UPDATE\"] = 3] = \"UPDATE\";\n    EstimateResult[EstimateResult[\"UNIDENTIFIED\"] = 4] = \"UNIDENTIFIED\";\n    EstimateResult[EstimateResult[\"ERROR\"] = 5] = \"ERROR\";\n})(EstimateResult = exports.EstimateResult || (exports.EstimateResult = {}));\nvar MainUpdateFlags;\n(function (MainUpdateFlags) {\n    /** if no change exists */ MainUpdateFlags[MainUpdateFlags[\"NOP\"] = 0] = \"NOP\";\n    /** if some change exists */ MainUpdateFlags[MainUpdateFlags[\"CHANGE\"] = 1] = \"CHANGE\";\n    /** if the change is insert (in the middle of the log), not add */ MainUpdateFlags[MainUpdateFlags[\"INBETWEEN\"] = 2] = \"INBETWEEN\";\n    /** if type of the change is undo(delete) */ MainUpdateFlags[MainUpdateFlags[\"UNDO\"] = 4] = \"UNDO\";\n    /** if type of the change is gross (both add/insert) */ MainUpdateFlags[MainUpdateFlags[\"GROSS\"] = 8] = \"GROSS\";\n    /** if type of the change is screen-erase (both add/insert) */ MainUpdateFlags[MainUpdateFlags[\"ERASE\"] = 16] = \"ERASE\";\n})(MainUpdateFlags = exports.MainUpdateFlags || (exports.MainUpdateFlags = {}));\n\n\n//# sourceURL=webpack:///./src/contentManager.ts?");

/***/ }),

/***/ "./src/dialogConfig.ts":
/*!*****************************!*\
  !*** ./src/dialogConfig.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DialogConfig = void 0;\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nconst log_1 = __importDefault(__webpack_require__(/*! ./log */ \"./src/log.ts\"));\nclass DialogConfig {\n    constructor() {\n        this.container = document.getElementById('config-container');\n        this.pane = document.getElementById(\"config\");\n        this.GeneralTab = document.getElementById('menu-general');\n        this.paren1 = document.getElementById(\"config-input_parentheses_1\");\n        this.paren2 = document.getElementById(\"config-input_parentheses_2\");\n        this.parenShift1 = document.getElementById(\"config-input_parenthesesShift_1\");\n        this.parenShift2 = document.getElementById(\"config-input_parenthesesShift_2\");\n        this.selectLocale = document.getElementById(\"config-select-locale\");\n        this.buttonOK = document.getElementById('config-button-ok');\n        this.buttonCancel = document.getElementById('config-button-cancel');\n        this.buttonOpen = document.getElementById('config-open');\n        this.buttonSave = document.getElementById('config-save');\n        this.buttonReset = document.getElementById('config-reset');\n        this.locales = [];\n        this.paneNames = [];\n        this.doOnSet = (n) => { };\n        this.onOpenClicked = () => { };\n        this.onSaveClicked = () => { };\n        this.onResetClicked = () => { };\n        this.setTitle(t_1.T.t(\"Config\", \"Config\"));\n        this.buttonOK.addEventListener('click', ev => {\n            this.dialogToConfig();\n            this.hideDialog();\n            this.doOnSet(this.paneNames);\n        });\n        this.buttonCancel.addEventListener('click', ev => {\n            this.hideDialog();\n        });\n        this.buttonOpen.addEventListener('click', ev => {\n            this.onOpenClicked();\n        });\n        this.buttonSave.addEventListener('click', ev => {\n            this.dialogToConfig();\n            this.onSaveClicked();\n        });\n        this.buttonReset.addEventListener('click', ev => {\n            this.onResetClicked();\n        });\n    } // end of constructor\n    getChangedPanes() {\n        return this.paneNames;\n    }\n    setOnSet(callback) {\n        this.doOnSet = (names) => callback(names);\n    }\n    setTitle(title) {\n        // nop\n    }\n    showDialog() {\n        if (this.locales.length < 1) {\n            this.locales = t_1.T.getLocales();\n            for (var locale of this.locales) {\n                utilDom_1.UtilDom.addSelectOption(this.selectLocale, locale.v2, locale.v1);\n            }\n        }\n        this.configToDialog();\n        this.GeneralTab.click();\n        utilDom_1.UtilDom.show(this.container);\n    }\n    hideDialog() {\n        utilDom_1.UtilDom.hide(this.container);\n    }\n    configToDialog() {\n        // search input elements which id starts \"config_\", then apply config value for text/color/checkbox\n        const elms = this.pane.getElementsByTagName(\"input\");\n        const len = elms.length;\n        for (var i = 0; i < len; i++) {\n            const elm = elms[i];\n            if (!elm.id.startsWith(\"config_\"))\n                continue;\n            const key = elm.id.substr(7);\n            if (appConfig_1.AppConfig.data[key] != undefined) {\n                if (elm.type === \"text\" || elm.type === \"number\") {\n                    elms[i].value = appConfig_1.AppConfig.data[key].toString();\n                }\n                else if (elm.type === \"color\") {\n                    elms[i].value = appConfig_1.AppConfig.data[key].toString();\n                }\n                else if (elm.type === \"checkbox\") {\n                    if (appConfig_1.AppConfig.data[key] === true) {\n                        elms[i].checked = true;\n                    }\n                    else if (appConfig_1.AppConfig.data[key] === false) {\n                        elms[i].checked = false;\n                    }\n                    else {\n                        log_1.default.w('Warning', `configToDialog checkbox item --- not boolean [${elm.id}]`);\n                    }\n                }\n                else {\n                    log_1.default.w('Warning', `configToDialog type not found id:${key}`);\n                }\n            }\n            else if (appConfig_1.AppConfig.data[elm.name] != undefined) {\n                const c = appConfig_1.AppConfig.data[elm.name];\n                if (elm.type === \"radio\") {\n                    var isMatch = false;\n                    switch (typeof c) {\n                        case \"string\":\n                            isMatch = c === elm.value;\n                            break;\n                        case \"number\":\n                            isMatch = c === Number(elm.value);\n                            break;\n                        case \"boolean\":\n                            isMatch = c === (elm.value.toLowerCase() === \"true\");\n                            break;\n                    }\n                    if (isMatch) {\n                        elms[i].checked = true;\n                    }\n                }\n                else {\n                    log_1.default.w('Warning', `configToDialog type not found name:${elm.name} (id:${elm.id})`);\n                }\n            }\n            else {\n                log_1.default.w('Warning', `configToDialog assign failed id:${elm.id} name:${elm.name}`);\n            }\n        }\n        // special items\n        this.paren1.value = appConfig_1.AppConfig.data.getParentheses1();\n        this.paren2.value = appConfig_1.AppConfig.data.getParentheses2();\n        this.parenShift1.value = appConfig_1.AppConfig.data.getParenthesesShift1();\n        this.parenShift2.value = appConfig_1.AppConfig.data.getParenthesesShift2();\n        // initialize selection of locale select-box\n        var localeIx = 0;\n        const current = t_1.T.matchLocale(appConfig_1.AppConfig.data.getLocale());\n        for (var ix = 0; ix < this.locales.length; ix++) {\n            if (this.locales[ix].v1 === current) {\n                localeIx = ix;\n                break;\n            }\n        }\n        this.selectLocale.selectedIndex = localeIx;\n    }\n    dialogToConfig() {\n        const elms = this.pane.getElementsByTagName(\"input\");\n        const len = elms.length;\n        this.paneNames = [];\n        for (var i = 0; i < len; i++) {\n            if (!elms[i].id.startsWith(\"config_\"))\n                continue;\n            var key = \"\";\n            if (elms[i].type === \"radio\") {\n                if (elms[i].checked) {\n                    key = elms[i].name; // For radio, there're many ids for single config item. Instead, name matches the item's key.\n                }\n                else {\n                    continue; // ignore non-checked radiobox\n                }\n            }\n            else {\n                key = elms[i].id.substr(7);\n            }\n            if (key !== \"\" && appConfig_1.AppConfig.data[key] === undefined) {\n                log_1.default.w('Warning', `dialogToConfig not found : key=${key} element:${elms[i].id}`);\n                continue;\n            }\n            const category = key.substring(0, key.indexOf(\"_\"));\n            var changed = false;\n            if (typeof appConfig_1.AppConfig.data[key] === \"string\" || appConfig_1.AppConfig.data[key] instanceof String) {\n                if (appConfig_1.AppConfig.data[key] !== elms[i].value) {\n                    appConfig_1.AppConfig.data[key] = elms[i].value;\n                    changed = true;\n                }\n            }\n            else if (typeof appConfig_1.AppConfig.data[key] === \"number\" || appConfig_1.AppConfig.data[key] instanceof Number) {\n                const n = Number(elms[i].value);\n                if (n === undefined || n === null)\n                    continue;\n                if (appConfig_1.AppConfig.data[key] !== n) {\n                    appConfig_1.AppConfig.data[key] = n;\n                    changed = true;\n                }\n            }\n            else if (typeof appConfig_1.AppConfig.data[key] === \"boolean\" || appConfig_1.AppConfig.data[key] instanceof Boolean) {\n                if (elms[i].type === \"checkbox\") {\n                    if (appConfig_1.AppConfig.data[key] !== elms[i].checked) {\n                        appConfig_1.AppConfig.data[key] = elms[i].checked;\n                        changed = true;\n                    }\n                }\n                else {\n                    log_1.default.w('Warning', `config [${key}] matched non-checkbox input (id=${elms[i].id})`);\n                }\n            }\n            else {\n                log_1.default.w('Warning', `configToDialog assign failed : [${elms[i].id}]`);\n            }\n            if (changed && !this.paneNames.includes(category)) {\n                this.paneNames.push(category);\n            }\n        }\n        // special items\n        var rParen = false;\n        if (appConfig_1.AppConfig.data.setParentheses1(this.paren1.value)) {\n            rParen = true;\n        }\n        if (appConfig_1.AppConfig.data.setParentheses2(this.paren2.value)) {\n            rParen = true;\n        }\n        if (appConfig_1.AppConfig.data.setParenthesesShift1(this.parenShift1.value)) {\n            rParen = true;\n        }\n        if (appConfig_1.AppConfig.data.setParenthesesShift2(this.parenShift2.value)) {\n            rParen = true;\n        }\n        if (rParen && !this.paneNames.includes(\"input\")) {\n            this.paneNames.push(\"input\");\n        }\n        const current = t_1.T.matchLocale(appConfig_1.AppConfig.data.getLocale());\n        const selectedLocale = this.locales[this.selectLocale.selectedIndex].v1;\n        if (selectedLocale !== current) {\n            appConfig_1.AppConfig.data.setLocale(selectedLocale);\n            this.paneNames.push(\"misc\");\n        }\n    }\n}\nexports.DialogConfig = DialogConfig;\n\n\n//# sourceURL=webpack:///./src/dialogConfig.ts?");

/***/ }),

/***/ "./src/dialogConfigViewer.ts":
/*!***********************************!*\
  !*** ./src/dialogConfigViewer.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DialogConfigViewer = void 0;\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nconst log_1 = __importDefault(__webpack_require__(/*! ./log */ \"./src/log.ts\"));\nclass DialogConfigViewer {\n    constructor() {\n        this.container = document.getElementById('config-view-container');\n        this.pane = document.getElementById(\"config-view\");\n        this.GeneralTab = document.getElementById('menu-view-general');\n        this.selectLocale = document.getElementById(\"config-view-select-locale\");\n        this.buttonOK = document.getElementById('config-view-button-ok');\n        this.buttonCancel = document.getElementById('config-view-button-cancel');\n        this.buttonOpen = document.getElementById('config-view-open');\n        this.buttonSave = document.getElementById('config-view-save');\n        this.buttonReset = document.getElementById('config-view-reset');\n        this.locales = [];\n        this.paneNames = [];\n        this.doOnSet = (n) => { };\n        this.onOpenClicked = () => { };\n        this.onSaveClicked = () => { };\n        this.onResetClicked = () => { };\n        this.setTitle(t_1.T.t(\"Config\", \"Config\"));\n        this.buttonOK.addEventListener('click', ev => {\n            this.dialogToConfig();\n            this.hideDialog();\n            this.doOnSet(this.paneNames);\n        });\n        this.buttonCancel.addEventListener('click', ev => {\n            this.hideDialog();\n        });\n        this.buttonOpen.addEventListener('click', ev => {\n            this.onOpenClicked();\n        });\n        this.buttonSave.addEventListener('click', ev => {\n            this.dialogToConfig();\n            this.onSaveClicked();\n        });\n        this.buttonReset.addEventListener('click', ev => {\n            this.onResetClicked();\n        });\n    } // end of constructor\n    getChangedPanes() {\n        return this.paneNames;\n    }\n    setOnSet(callback) {\n        this.doOnSet = (names) => callback(names);\n    }\n    setTitle(title) {\n        // nop\n    }\n    showDialog() {\n        if (this.locales.length < 1) {\n            this.locales = t_1.T.getLocales();\n            for (var locale of this.locales) {\n                utilDom_1.UtilDom.addSelectOption(this.selectLocale, locale.v2, locale.v1);\n            }\n        }\n        this.configToDialog();\n        this.GeneralTab.click();\n        utilDom_1.UtilDom.show(this.container);\n    }\n    hideDialog() {\n        utilDom_1.UtilDom.hide(this.container);\n    }\n    configToDialog() {\n        // search input elements which id starts \"config_\", then apply config value for text/color/checkbox\n        const elms = this.pane.getElementsByTagName(\"input\");\n        const len = elms.length;\n        for (var i = 0; i < len; i++) {\n            const elm = elms[i];\n            if (!elm.id.startsWith(\"config_\"))\n                continue;\n            const key = elm.id.substr(7);\n            if (appConfig_1.AppConfig.data[key] != undefined) {\n                if (elm.type === \"text\" || elm.type === \"number\") {\n                    elms[i].value = appConfig_1.AppConfig.data[key].toString();\n                }\n                else if (elm.type === \"color\") {\n                    elms[i].value = appConfig_1.AppConfig.data[key].toString();\n                }\n                else if (elm.type === \"checkbox\") {\n                    if (appConfig_1.AppConfig.data[key] === true) {\n                        elms[i].checked = true;\n                    }\n                    else if (appConfig_1.AppConfig.data[key] === false) {\n                        elms[i].checked = false;\n                    }\n                    else {\n                        log_1.default.w('Warning', `configToDialog checkbox item --- not boolean [${elm.id}]`);\n                    }\n                }\n                else {\n                    log_1.default.w('Warning', `configToDialog type not found id:${key}`);\n                }\n            }\n            else if (appConfig_1.AppConfig.data[elm.name] != undefined) {\n                const c = appConfig_1.AppConfig.data[elm.name];\n                if (elm.type === \"radio\") {\n                    var isMatch = false;\n                    switch (typeof c) {\n                        case \"string\":\n                            isMatch = c === elm.value;\n                            break;\n                        case \"number\":\n                            isMatch = c === Number(elm.value);\n                            break;\n                        case \"boolean\":\n                            isMatch = c === (elm.value.toLowerCase() === \"true\");\n                            break;\n                    }\n                    if (isMatch) {\n                        elms[i].checked = true;\n                    }\n                }\n                else {\n                    log_1.default.w('Warning', `configToDialog type not found name:${elm.name} (id:${elm.id})`);\n                }\n            }\n            else {\n                log_1.default.w('Warning', `configToDialog assign failed id:${elm.id} name:${elm.name}`);\n            }\n        }\n        // initialize selection of locale select-box\n        var localeIx = 0;\n        const current = t_1.T.matchLocale(appConfig_1.AppConfig.data.getLocale());\n        for (var ix = 0; ix < this.locales.length; ix++) {\n            if (this.locales[ix].v1 === current) {\n                localeIx = ix;\n                break;\n            }\n        }\n        this.selectLocale.selectedIndex = localeIx;\n    }\n    dialogToConfig() {\n        const elms = this.pane.getElementsByTagName(\"input\");\n        const len = elms.length;\n        this.paneNames = [];\n        for (var i = 0; i < len; i++) {\n            if (!elms[i].id.startsWith(\"config_\"))\n                continue;\n            var key = \"\";\n            if (elms[i].type === \"radio\") {\n                if (elms[i].checked) {\n                    key = elms[i].name; // For radio, there're many ids for single config item. Instead, name matches the item's key.\n                }\n                else {\n                    continue; // ignore non-checked radiobox\n                }\n            }\n            else {\n                key = elms[i].id.substr(7);\n            }\n            if (key !== \"\" && appConfig_1.AppConfig.data[key] === undefined) {\n                log_1.default.w('Warning', `dialogToConfig not found : key=${key} element:${elms[i].id}`);\n                continue;\n            }\n            const category = key.substring(0, key.indexOf(\"_\"));\n            var changed = false;\n            if (typeof appConfig_1.AppConfig.data[key] === \"string\" || appConfig_1.AppConfig.data[key] instanceof String) {\n                if (appConfig_1.AppConfig.data[key] !== elms[i].value) {\n                    appConfig_1.AppConfig.data[key] = elms[i].value;\n                    changed = true;\n                }\n            }\n            else if (typeof appConfig_1.AppConfig.data[key] === \"number\" || appConfig_1.AppConfig.data[key] instanceof Number) {\n                const n = Number(elms[i].value);\n                if (n === undefined || n === null)\n                    continue;\n                if (appConfig_1.AppConfig.data[key] !== n) {\n                    appConfig_1.AppConfig.data[key] = n;\n                    changed = true;\n                }\n            }\n            else if (typeof appConfig_1.AppConfig.data[key] === \"boolean\" || appConfig_1.AppConfig.data[key] instanceof Boolean) {\n                if (elms[i].type === \"checkbox\") {\n                    if (appConfig_1.AppConfig.data[key] !== elms[i].checked) {\n                        appConfig_1.AppConfig.data[key] = elms[i].checked;\n                        changed = true;\n                    }\n                }\n                else {\n                    log_1.default.w('Warning', `config [${key}] matched non-checkbox input (id=${elms[i].id})`);\n                }\n            }\n            else {\n                log_1.default.w('Warning', `configToDialog assign failed : [${elms[i].id}]`);\n            }\n            if (changed && !this.paneNames.includes(category)) {\n                this.paneNames.push(category);\n            }\n        }\n        // special items\n        const current = t_1.T.matchLocale(appConfig_1.AppConfig.data.getLocale());\n        const selectedLocale = this.locales[this.selectLocale.selectedIndex].v1;\n        if (selectedLocale !== current) {\n            appConfig_1.AppConfig.data.setLocale(selectedLocale);\n            this.paneNames.push(\"misc\");\n        }\n    }\n}\nexports.DialogConfigViewer = DialogConfigViewer;\n\n\n//# sourceURL=webpack:///./src/dialogConfigViewer.ts?");

/***/ }),

/***/ "./src/dialogInput.ts":
/*!****************************!*\
  !*** ./src/dialogInput.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass DialogInput {\n    constructor() {\n        this.dialog = document.getElementById('inputdialog');\n        this.label = document.getElementById('inputdialog_label');\n        this.input = document.getElementById('inputdialog_text');\n        this.buttonOk = document.getElementById('inputdialog-ok-button');\n        this.buttonCancel = document.getElementById('inputdialog-cancel-button');\n        this.onOkClick = text => { };\n        this.onCancelClick = () => { };\n        this.buttonOk.addEventListener('click', ev => {\n            this.hideDialog();\n            this.onOkClick(this.input.value);\n            this.resetOkCancelEvents();\n        });\n        this.buttonCancel.addEventListener('click', ev => {\n            this.hideDialog();\n            this.onCancelClick();\n            this.resetOkCancelEvents();\n        });\n    }\n    resetOkCancelEvents() {\n        this.onOkClick = () => { };\n        this.onCancelClick = () => { };\n    }\n    showDialog(label, initialValue = '') {\n        this.label.textContent = label;\n        this.input.value = initialValue;\n        utilDom_1.UtilDom.show(this.dialog);\n        this.input.focus();\n    }\n    hideDialog() {\n        utilDom_1.UtilDom.hide(this.dialog);\n    }\n}\nexports.default = DialogInput;\n\n\n//# sourceURL=webpack:///./src/dialogInput.ts?");

/***/ }),

/***/ "./src/dialogLogin.ts":
/*!****************************!*\
  !*** ./src/dialogLogin.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nconst loginInfo_1 = __importDefault(__webpack_require__(/*! ./loginInfo */ \"./src/loginInfo.ts\"));\nclass DialogLogin {\n    constructor() {\n        this.dialogLogin = document.getElementById('login');\n        this.roomRow = document.getElementById('loginTable_roomRow');\n        this.nameRow = document.getElementById('loginTable_nameRow');\n        this.passRow = document.getElementById('loginTable_passRow');\n        this.viewerRadio = document.getElementById('role0');\n        this.subtitlerRadio = document.getElementById('role1');\n        this.roomInput = document.getElementById('login-input-room');\n        this.nameInput = document.getElementById('login-input-name');\n        this.passInput = document.getElementById('login-input-pass');\n        this.buttonLogin = document.getElementById('login-button');\n        this.downloadPane = document.getElementById('loginDialog_log_download_pane');\n        this.buttonDownloadMain = document.getElementById('loginDialog_main_log_download');\n        this.buttonDownloadChat = document.getElementById('loginDialog_chat_log_download');\n        /** Condition for login (set from outside) */\n        this.loginCondition = 0;\n        this.onLoginClick = i => { };\n        this.onDownloadMain = () => { };\n        this.onDownloadChat = () => { };\n        this.setEvents();\n        this.updateState();\n    }\n    /** Set value for login (set from outside) */\n    setLoginCondition(cond) {\n        this.loginCondition = cond;\n        this.updateState();\n    }\n    setEvents() {\n        this.buttonLogin.addEventListener('click', (ev) => {\n            const info = new loginInfo_1.default();\n            info.room = this.roomInput.value;\n            info.memberType = (this.subtitlerRadio.checked) ? 'wi' : 'wv';\n            info.name = this.nameInput.value;\n            info.pass = this.passInput.value;\n            this.hideDialog();\n            this.onLoginClick(info);\n        });\n        this.buttonDownloadMain.addEventListener('click', ev => { this.onDownloadMain(); });\n        this.buttonDownloadChat.addEventListener('click', ev => { this.onDownloadChat(); });\n        this.viewerRadio.addEventListener('change', ev => {\n            this.updateState();\n            this.focusMe();\n        });\n        this.subtitlerRadio.addEventListener('change', ev => {\n            this.updateState();\n            this.focusMe();\n        });\n        this.dialogLogin.addEventListener('change', ev => { this.updateState(); });\n        this.dialogLogin.addEventListener('input', ev => { this.updateState(); });\n        this.dialogLogin.addEventListener('paste', ev => { this.updateState(); });\n    }\n    updateState() {\n        if (this.subtitlerRadio.checked) {\n            this.showName();\n        }\n        else {\n            this.hideName();\n        }\n        // if all inputs are hidden, always login-able.\n        if (utilDom_1.UtilDom.isDisplayed(this.roomRow) === false\n            && utilDom_1.UtilDom.isDisplayed(this.nameRow) === false\n            && utilDom_1.UtilDom.isDisplayed(this.passRow) === false) {\n            this.buttonLogin.disabled = false;\n        }\n        var canLogin = true;\n        if (utilDom_1.UtilDom.isDisplayed(this.roomRow)) {\n            if (this.roomInput.value.length < 1) {\n                canLogin = false;\n            }\n            if (this.roomInput.validationMessage.length > 0) {\n                canLogin = false;\n            }\n        }\n        if (utilDom_1.UtilDom.isDisplayed(this.nameRow)) {\n            if (this.nameInput.value.length < 1) {\n                canLogin = false;\n            }\n        }\n        if (utilDom_1.UtilDom.isDisplayed(this.passRow)) {\n            if (this.passInput.value.length < 1) {\n                canLogin = false;\n            }\n        }\n        if (this.loginCondition < 1) {\n            canLogin = false;\n        }\n        this.buttonLogin.disabled = !canLogin;\n    }\n    setRoom(room) {\n        this.roomInput.value = room;\n    }\n    setName(name) {\n        this.nameInput.value = name;\n    }\n    showDialog(canGetMain = false, canGetChat = false) {\n        if (canGetMain === true) {\n            utilDom_1.UtilDom.displayOn(this.buttonDownloadMain);\n        }\n        else {\n            utilDom_1.UtilDom.displayOff(this.buttonDownloadMain);\n        }\n        if (canGetChat === true) {\n            utilDom_1.UtilDom.displayOn(this.buttonDownloadChat);\n        }\n        else {\n            utilDom_1.UtilDom.displayOff(this.buttonDownloadChat);\n        }\n        utilDom_1.UtilDom.show(this.dialogLogin);\n        this.updateState();\n        this.focusMe();\n    }\n    isShown() {\n        return utilDom_1.UtilDom.isShown(this.dialogLogin);\n    }\n    focusMe() {\n        const showRoom = utilDom_1.UtilDom.isDisplayed(this.roomRow);\n        const showName = utilDom_1.UtilDom.isDisplayed(this.nameRow);\n        if (showRoom) {\n            this.roomInput.focus();\n        }\n        else if (showName) {\n            this.nameInput.focus();\n        }\n        else {\n            this.buttonLogin.focus();\n        }\n    }\n    hideDialog() {\n        utilDom_1.UtilDom.hide(this.dialogLogin);\n    }\n    showRoom() {\n        this.roomInput.required = true;\n        utilDom_1.UtilDom.displayOn(this.roomRow, \"table-row\");\n    }\n    hideRoom() {\n        this.roomInput.required = false;\n        utilDom_1.UtilDom.displayOff(this.roomRow);\n    }\n    showName() {\n        this.nameInput.required = true;\n        utilDom_1.UtilDom.displayOn(this.nameRow, \"table-row\");\n    }\n    hideName() {\n        this.nameInput.required = false;\n        utilDom_1.UtilDom.displayOff(this.nameRow);\n    }\n    showPass() {\n        this.passInput.required = true;\n        utilDom_1.UtilDom.displayOn(this.passRow, \"table-row\");\n    }\n    hidePass() {\n        this.passInput.required = false;\n        utilDom_1.UtilDom.displayOff(this.passRow);\n    }\n}\nexports.default = DialogLogin;\n\n\n//# sourceURL=webpack:///./src/dialogLogin.ts?");

/***/ }),

/***/ "./src/dialogNotify.ts":
/*!*****************************!*\
  !*** ./src/dialogNotify.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass DialogNotify {\n    constructor() {\n        this.dialog = document.getElementById('notify');\n        this.title = document.getElementById('notify-title');\n        this.message = document.getElementById('notify-message');\n        this.buttonPane = document.getElementById('notify-buttons');\n        this.okButton = document.getElementById('notify-ok-button');\n        this.onOkClick = () => { };\n        this.okButton.addEventListener('click', () => {\n            this.hideDialog();\n            this.onOkClick();\n            this.resetOkEvents();\n        });\n    }\n    resetOkEvents() {\n        this.onOkClick = () => { };\n    }\n    showDialog(title, message) {\n        this.title.textContent = title;\n        this.message.textContent = message;\n        utilDom_1.UtilDom.show(this.dialog);\n        // do not focus okButton, because dialog would be closed just after shown (think you hit enter key in login button with wrong password)\n    }\n    hideDialog() {\n        utilDom_1.UtilDom.hide(this.dialog);\n    }\n}\nexports.default = DialogNotify;\n\n\n//# sourceURL=webpack:///./src/dialogNotify.ts?");

/***/ }),

/***/ "./src/fileController.ts":
/*!*******************************!*\
  !*** ./src/fileController.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Downloader = void 0;\nclass Downloader {\n    constructor() { }\n    static start(filename, content) {\n        this.dlLink.download = filename;\n        this.dlLink.href = URL.createObjectURL(new Blob([content], { type: 'text/plain' }));\n        this.dlLink.click();\n    }\n}\nexports.Downloader = Downloader;\nDownloader.dlLink = document.getElementById('file-download');\nclass FileController {\n    constructor(idOpener) {\n        this.onAbort = (e, f) => { };\n        this.onError = (e, f) => { };\n        this.onLoad = (e, f) => { };\n        // File element should be different by FileController instance (dlLink can be same)\n        this.opener = document.getElementById(idOpener);\n        this.opener.onchange = ev => {\n            var _a;\n            if (((_a = this.opener.files) === null || _a === void 0 ? void 0 : _a.length) === 1) {\n                const reader = new FileReader();\n                const file = this.opener.files[0];\n                reader.onabort = ev => { this.onAbort(ev, file); };\n                reader.onerror = ev => { this.onError(ev, file); };\n                reader.onload = ev => { this.onLoad(ev, file); };\n                reader.readAsText(file);\n            }\n        };\n    }\n    openDialogAndReadFile(filetype) {\n        if (filetype != null) {\n            this.opener.accept = filetype;\n        }\n        this.opener.click();\n    }\n}\nexports.default = FileController;\n\n\n//# sourceURL=webpack:///./src/fileController.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst app_1 = __importDefault(__webpack_require__(/*! ./app */ \"./src/app.ts\"));\nvar _app;\ndocument.addEventListener('DOMContentLoaded', () => {\n    const app = new app_1.default();\n    _app = app;\n});\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/log.ts":
/*!********************!*\
  !*** ./src/log.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nclass Log {\n    static w(level, message) {\n        const n = util_1.Util.getNowUTCTimeString();\n        console.log(`${n} [${level}] ${message}`);\n    }\n}\nexports.default = Log;\n\n\n//# sourceURL=webpack:///./src/log.ts?");

/***/ }),

/***/ "./src/loginInfo.ts":
/*!**************************!*\
  !*** ./src/loginInfo.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass LoginInfo {\n    constructor() {\n        this.room = \"\";\n        this.name = \"\";\n        this.memberType = \"\";\n        this.pass = \"\";\n    }\n    static clone(src) {\n        const i = new LoginInfo();\n        i.room = src.room;\n        i.name = src.name;\n        i.memberType = src.memberType;\n        i.pass = src.pass;\n        return i;\n    }\n}\nexports.default = LoginInfo;\n\n\n//# sourceURL=webpack:///./src/loginInfo.ts?");

/***/ }),

/***/ "./src/mekikuAnalyzer.ts":
/*!*******************************!*\
  !*** ./src/mekikuAnalyzer.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MekikuUnitDataForEstimate = exports.MekikuUnitDataClass = exports.MekikuUnitDataFlags = void 0;\nconst content_1 = __webpack_require__(/*! ./content */ \"./src/content.ts\");\nvar MekikuUnitDataFlags;\n(function (MekikuUnitDataFlags) {\n    MekikuUnitDataFlags[MekikuUnitDataFlags[\"NORMAL\"] = 0] = \"NORMAL\";\n    MekikuUnitDataFlags[MekikuUnitDataFlags[\"UNDONE\"] = 1] = \"UNDONE\";\n})(MekikuUnitDataFlags = exports.MekikuUnitDataFlags || (exports.MekikuUnitDataFlags = {}));\n/**\n * class implements MekikuUnitData with constructor\n */\nclass MekikuUnitDataClass {\n    constructor() {\n        this.id = \"\";\n        this.name = \"\";\n        this.receivedMsec = 0;\n        this.sentMsec = 0;\n        this.memberType = content_1.MemberType.WEB_SUBTITLER;\n        this.contentType = \"\";\n        this.flag = 0;\n        this.content = \"\";\n    }\n    static fromContent(v) {\n        const r = new MekikuUnitDataClass();\n        r.id = v.senderID;\n        r.name = v.senderName;\n        r.sentMsec = v.sendTimeCount;\n        r.receivedMsec = v.receiveTimeCount;\n        r.memberType = v.memberType;\n        return r;\n    }\n}\nexports.MekikuUnitDataClass = MekikuUnitDataClass;\n/**\n * single mekiku item (display, gross, erase, undo and chat)\n * to analyze and log(main,chat).\n */\nclass MekikuUnitDataForEstimate {\n    /**\n     * Cloning constructor for MekikuUnitData\n     * notice: estimatedRecvMsec is set as receivedMsrc. Estimate later.\n     * @param src source data\n     */\n    constructor(src) {\n        /** (variable) lines divided by display-width */\n        this.lines = [];\n        this.id = src.id;\n        this.name = src.name;\n        this.receivedMsec = src.receivedMsec;\n        this.sentMsec = src.sentMsec;\n        this.memberType = src.memberType;\n        this.contentType = src.contentType;\n        this.sentTimeOriginal = src.sentTimeOriginal;\n        this.flag = src.flag;\n        this.content = src.content;\n        this.estimatedRecvMsec = this.receivedMsec;\n        this.sentTimeAnyway = (this.sentTimeOriginal === undefined)\n            ? this.sentMsec\n            : this.sentTimeOriginal;\n    }\n}\nexports.MekikuUnitDataForEstimate = MekikuUnitDataForEstimate;\n\n\n//# sourceURL=webpack:///./src/mekikuAnalyzer.ts?");

/***/ }),

/***/ "./src/mekikuComm.ts":
/*!***************************!*\
  !*** ./src/mekikuComm.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/// <reference types=\"skyway\" />\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MekikuCommEvents = void 0;\nconst log_1 = __importDefault(__webpack_require__(/*! ./log */ \"./src/log.ts\"));\nconst content_1 = __webpack_require__(/*! ./content */ \"./src/content.ts\");\nconst loginInfo_1 = __importDefault(__webpack_require__(/*! ./loginInfo */ \"./src/loginInfo.ts\"));\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nclass MekikuCommEvents {\n    constructor() {\n        /** called when Peer-ID confirmed */\n        this.onPeerIdAcquired = (id) => { };\n        /** called when error occured on Peer level */\n        this.onPeerError = (err) => { };\n        /** called when someone sends a message */\n        this.onReceived = (d) => { };\n        /** called when you joined a room */\n        this.onJoinedRoom = () => { };\n        /** called when you left the room */\n        this.onLeftRoom = () => { };\n        /** called when someone joined the room you are in */\n        this.onSomeoneJoined = (id) => { };\n        /** called when someone left the room you are in */\n        this.onSomeoneLeft = (id) => { };\n        this.logger = (msg) => { };\n    }\n}\nexports.MekikuCommEvents = MekikuCommEvents;\nclass MekikuCommOpenOptionClass {\n    constructor() {\n        this.debugLevel = 2;\n        this.handleOpen = id => { };\n    }\n}\n/**\n * Communication class for mekiku-web\n */\nclass MekikuComm {\n    constructor(eventHandlers) {\n        /** called when Peer-ID confirmed */\n        this.onPeerIdAcquired = (id) => { };\n        /** called when error occured on Peer level */\n        this.onPeerError = (err) => { };\n        /** called when someone sends a message */\n        this.onReceived = (d) => { };\n        /** called when you joined a room */\n        this.onJoinedRoom = () => { };\n        /** called when you left the room */\n        this.onLeftRoom = () => { };\n        /** called when someone joined the room you are in */\n        this.onSomeoneJoined = (id) => { };\n        /** called when someone left the room you are in */\n        this.onSomeoneLeft = (id) => { };\n        this.logger = (msg) => { };\n        if (eventHandlers != null) {\n            this.onPeerIdAcquired = eventHandlers.onPeerIdAcquired;\n            this.onPeerError = eventHandlers.onPeerError;\n            this.onJoinedRoom = eventHandlers.onJoinedRoom;\n            this.onLeftRoom = eventHandlers.onLeftRoom;\n            this.onReceived = eventHandlers.onReceived;\n            this.onSomeoneJoined = eventHandlers.onSomeoneJoined;\n            this.onSomeoneLeft = eventHandlers.onSomeoneLeft;\n            this.logger = eventHandlers.logger;\n        }\n    }\n    isOpen() {\n        var _a;\n        return ((_a = this.peer) === null || _a === void 0 ? void 0 : _a.open) === true;\n    }\n    getInfo() {\n        return this.info == null ? undefined : loginInfo_1.default.clone(this.info);\n    }\n    isInRoom() {\n        return this.info != null;\n    }\n    /**\n     * Open connection with signaling server (if not opened).\n     * @param key Skyway API key\n     * @param debugLevel debug level (NONE=0, ERROR=1, WARN=2, FULL=3)\n     * @param id [option] Explicit peer-id\n     */\n    open(key, option) {\n        var _a;\n        if (((_a = this.peer) === null || _a === void 0 ? void 0 : _a.open) === true) {\n            log_1.default.w('Info', `comm.open : old peer(id=${this.peer.id}) remains. disconnecting...`);\n            this.peer.disconnect();\n        }\n        this.openOption = { ...new MekikuCommOpenOptionClass(), ...option };\n        const opt = {\n            key: key,\n            debug: this.openOption.debugLevel,\n        };\n        if (this.openOption.id != null) {\n            // Log.w('Info',`comm.open : construct new peer(id=${this.openOption.id})`)\n            this.peer = new Peer(this.openOption.id, opt);\n        }\n        else {\n            // Log.w('Info',`comm.open : construct new peer(id: set by skyway)`)\n            this.peer = new Peer(opt);\n        }\n        this.setPeerEvents(this.peer);\n    }\n    /**\n     * Join room.\n     * @param room_name name of room to join\n     * @param mode connecting mode. \"sfu\" or \"mesh\" is available.\n     * @returns success(true) or fail(false)\n     */\n    joinRoom(info, mode = \"sfu\") {\n        log_1.default.w('Info', `joining room room:${info.room}, name:${info.name}, type:${info.memberType}, pass:${info.pass}, mode:${mode}`);\n        if (this.peer == null) {\n            log_1.default.w('Error', 'peer is null.');\n            return false;\n        }\n        if (!util_1.Util.isRoomNameLegit(info.room)) {\n            log_1.default.w('Error', `Illegal room name:[${info.room}]`);\n            return false;\n        }\n        const r = this.peer.joinRoom(info.room, {\n            mode: mode\n        });\n        if (r == null) {\n            log_1.default.w('Error', 'joinRoom failed.');\n            return false;\n        }\n        this.info = loginInfo_1.default.clone(info);\n        this.room = r;\n        this.setRoomEvents(this.room);\n        return true;\n    }\n    /**\n     * Leave room\n     */\n    leaveRoom() {\n        if (this.room != null) {\n            this.room.close();\n        }\n    }\n    /**\n     * Queue message to all room members (except self)\n     * @param data object to send\n     */\n    queue_room(data) {\n        var _a, _b, _c, _d;\n        const name = (_b = (_a = this.info) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n        const type = (_d = (_c = this.info) === null || _c === void 0 ? void 0 : _c.memberType) !== null && _d !== void 0 ? _d : content_1.MemberType.WEB_SUBTITLER;\n        const sendBase = new content_1.ContentToSendClass(name, type);\n        const d = { ...data, ...sendBase };\n        if (this.room != null) {\n            // Log.w('Info',`queue data:${JSON.stringify(d)}`)\n            this.room.send(d); // yet not queueing\n        }\n        else {\n            // Log.w('Info',`(no room, not sent) queue data:${JSON.stringify(d)}`)\n        }\n        return d;\n    }\n    /**\n     * send message to all room members (except self)\n     * @param data object to send\n     */\n    send_room(data) {\n        var _a, _b, _c, _d, _e;\n        const name = (_b = (_a = this.info) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n        const type = (_d = (_c = this.info) === null || _c === void 0 ? void 0 : _c.memberType) !== null && _d !== void 0 ? _d : content_1.MemberType.WEB_SUBTITLER;\n        const sendBase = new content_1.ContentToSendClass(name, type);\n        const d = { ...data, ...sendBase };\n        if (this.room != null) {\n            // Log.w('Info',`send data:${JSON.stringify(d)}`)\n            (_e = this.room) === null || _e === void 0 ? void 0 : _e.send(d);\n        }\n        else\n            [\n            // Log.w('Info',`(no room, not sent) data:${JSON.stringify(d)}`)\n            ];\n        return d;\n    }\n    setPeerEvents(p) {\n        p.on('open', id => {\n            var _a;\n            // Log.w('Info',`peer opened id=${id}`)\n            if (((_a = this.openOption) === null || _a === void 0 ? void 0 : _a.handleOpen) != null) {\n                this.openOption.handleOpen(id);\n                delete this.openOption;\n            }\n            this.onPeerIdAcquired(id);\n        });\n        p.on('close', () => {\n            // Log.w('Info',`peer closed`)\n        });\n        p.on('connection', conn => {\n            // Log.w('Info',`peer connected from ${JSON.stringify(conn)}`)\n        });\n        p.on('disconnected', id => {\n            // Log.w('Info',`peer disconnected id=${id}`)\n        });\n        p.on('error', err => {\n            log_1.default.w('Error', `peer error (${err.type}) <${err.message}>`);\n            this.onPeerError(err);\n        });\n    }\n    setRoomEvents(r) {\n        r.on('open', () => {\n            // Log.w('Info',`room opened`)\n            this.onJoinedRoom();\n        });\n        r.on('peerJoin', peerId => {\n            // Log.w('Info',`room : ${peerId} joined`)\n            this.onSomeoneJoined(peerId);\n        });\n        r.on('peerLeave', peerId => {\n            // Log.w('Info',`room : ${peerId} left`)\n            this.onSomeoneLeft(peerId);\n        });\n        r.on('data', ({ src, data }) => {\n            const t = Date.now();\n            // Log.w('Info',`room: data from ${src} : ${JSON.stringify(data)}`)\n            const d = content_1.ContentClass.fromAny(src, data);\n            if (d != null) {\n                this.onReceived(d);\n            }\n        });\n        r.on('close', () => {\n            var _a;\n            // Log.w('Info',`room closed`)\n            delete this.room;\n            delete this.info;\n            (_a = this.peer) === null || _a === void 0 ? void 0 : _a.disconnect();\n            this.onLeftRoom();\n        });\n    }\n}\nexports.default = MekikuComm;\n\n\n//# sourceURL=webpack:///./src/mekikuComm.ts?");

/***/ }),

/***/ "./src/memberManager.ts":
/*!******************************!*\
  !*** ./src/memberManager.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MemberInfoClass = void 0;\nclass MemberInfoClass {\n    constructor(id, mType) {\n        this.id = id;\n        this.memberType = mType;\n        this.lastReceived = Date.now();\n        this.lastSequence = 0;\n    }\n    static fromContent(data) {\n        const d = new MemberInfoClass(data.senderID, data.memberType);\n        d.name = data.senderName;\n        d.lastReceived = data.sendTimeCount;\n        d.lastSequence = data.seqCount;\n        return d;\n    }\n}\nexports.MemberInfoClass = MemberInfoClass;\n\n\n//# sourceURL=webpack:///./src/memberManager.ts?");

/***/ }),

/***/ "./src/paneChat.ts":
/*!*************************!*\
  !*** ./src/paneChat.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PaneChat = void 0;\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass PaneChat {\n    constructor() {\n        this.pane = document.getElementById('chat');\n        this.titlebar = document.getElementById('chat-title');\n        this.logArea = document.getElementById(\"chat-log\");\n        this.inputArea = document.getElementById(\"chat-input\");\n        this.buttonStart = document.getElementById(\"chat-timer-start\");\n        this.buttonPause = document.getElementById(\"chat-timer-pause\");\n        this.buttonResetTimer = document.getElementById(\"chat-timer-reset\");\n        this.textTimerNow = document.getElementById(\"chat-timer-now\");\n        this.buttonUp = document.getElementById(\"chat-timer-up\");\n        this.buttonDown = document.getElementById(\"chat-timer-down\");\n        this.textTimerValue = document.getElementById(\"chat-timer-value\");\n        this.countDownTimerId = -1;\n        this.countDown = 0;\n        this.countDownFrom = 0;\n        this.T_COUNTDOWN = 1000;\n        this.notifyTimerId = -1;\n        this.T_NOTIFY = 500;\n        this.isOnShow = false;\n        this.doOnSend = (m) => { };\n        this.getFkey = (ix) => { return \"\"; };\n        this.localize();\n        this.inputArea.addEventListener(\"keydown\", (ev) => {\n            // Only on macOS, when some key is typed while IME input, ev.key is same as when not IME inputing.\n            // https://qiita.com/ledsun/items/31e43a97413dd3c8e38e\n            if (ev.keyCode === utilDom_1.UtilDom.KEY_ENTER) {\n                this.onSend(this.inputArea.value);\n                this.inputArea.value = \"\";\n            }\n            else if (ev.keyCode === utilDom_1.UtilDom.KEY_ESC) {\n                this.inputArea.value = \"\";\n            }\n            const iFkey = utilDom_1.UtilDom.getCtrlOrFKeyNumber(ev) - 1;\n            if (iFkey >= 0 && iFkey < 7) {\n                const sFkey = this.getFkey(iFkey);\n                if (sFkey.length > 0) {\n                    this.insertText(sFkey);\n                }\n            }\n        });\n        this.buttonPause.disabled = true;\n        this.configToScreen();\n        this.setEventListeners();\n    }\n    getName() { return \"PaneChat\"; }\n    addMessage(sender, message) {\n        this.logArea.value += sender + t_1.T.t(\" : \", \"Chat\") + message + \"\\n\";\n        this.logArea.scrollTop = this.logArea.scrollHeight;\n        this.beginNotify();\n    }\n    addSystemMessage(message) {\n        const timestamp = (new Date()).toLocaleTimeString();\n        this.logArea.value += message + \" (\" + timestamp + \")\\n\";\n        this.logArea.scrollTop = this.logArea.scrollHeight;\n        this.beginNotify();\n    }\n    hasLog() {\n        return this.logArea.value.length > 0;\n    }\n    getLog() {\n        return this.logArea.value;\n    }\n    setOnSend(callback) { this.doOnSend = (m) => callback(m); }\n    onSend(message) { this.doOnSend(message); }\n    setGetFkey(callback) { this.getFkey = (ix) => callback(ix); }\n    setEventListeners() {\n        this.buttonUp.addEventListener(\"click\", (mouseEvent) => {\n            const newTime = this.timerText2Config() + 1;\n            if (this.isTimerPeriodValid(newTime)) {\n                this.setTimerPeriod(newTime);\n                this.timerConfig2Text();\n            }\n        });\n        this.buttonDown.addEventListener(\"click\", (mouseEvent) => {\n            const newTime = this.timerText2Config() - 1;\n            if (this.isTimerPeriodValid(newTime)) {\n                this.setTimerPeriod(newTime);\n                this.timerConfig2Text();\n            }\n        });\n        this.textTimerValue.addEventListener(\"change\", (ev) => {\n            this.timerText2Config();\n        });\n        this.buttonStart.addEventListener(\"click\", (mouseEvent) => {\n            this.startCountDown();\n        });\n        this.buttonPause.addEventListener(\"click\", (mouseEvent) => {\n            this.stopCountDown();\n        });\n        this.buttonResetTimer.addEventListener(\"click\", (mouseEvent) => {\n            this.resetCountDown();\n        });\n    }\n    insertText(text) {\n        if (this.inputArea.selectionStart == null)\n            return;\n        var begin = this.inputArea.selectionStart;\n        var end = this.inputArea.selectionStart;\n        if (this.inputArea.selectionEnd) {\n            begin = Math.min(this.inputArea.selectionStart, this.inputArea.selectionEnd);\n            end = Math.max(this.inputArea.selectionStart, this.inputArea.selectionEnd);\n        }\n        const before = this.inputArea.value.substr(0, begin);\n        const after = this.inputArea.value.substr(end);\n        this.inputArea.value = before + text + after;\n        const newPos = (before + text).length;\n        this.inputArea.setSelectionRange(newPos, newPos);\n    }\n    startCountDown() {\n        if (this.countDownTimerId >= 0)\n            return;\n        this.buttonStart.disabled = true;\n        this.buttonPause.disabled = false;\n        this.buttonResetTimer.disabled = true;\n        this.onSend(t_1.T.t(\"Timer started. Next \", \"Chat\")\n            + '[' + this.getRemainingTimeText() + ']'\n            + ' (' + (new Date()).toLocaleTimeString() + ')');\n        this.countDownTimerId = window.setInterval(() => {\n            this.onCount();\n        }, this.T_COUNTDOWN);\n    }\n    onCount() {\n        this.countDown--;\n        this.updateTimerNow();\n        if (this.countDown === 30) {\n            this.onSend(t_1.T.t(\"30 seconds to next turn.\", \"Chat\")\n                + ' (' + (new Date()).toLocaleTimeString() + ')');\n        }\n        else if (this.countDown === 0) {\n            this.onSend(t_1.T.t(\"It's new turn now.\", \"Chat\")\n                + ' (' + (new Date()).toLocaleTimeString() + ')');\n            const tNow = Number(this.textTimerValue.value);\n            if (isNaN(tNow) === false && this.isTimerPeriodValid(tNow)) {\n                this.countDownFrom = tNow * 60;\n            }\n            this.countDown = this.countDownFrom;\n        }\n    }\n    stopCountDown() {\n        if (this.countDownTimerId < 0)\n            return;\n        window.clearInterval(this.countDownTimerId);\n        this.countDownTimerId = -1;\n        this.buttonStart.disabled = false;\n        this.buttonPause.disabled = true;\n        this.buttonResetTimer.disabled = false;\n        this.onSend(t_1.T.t(\"Timer halted.\", \"Chat\")\n            + ' (' + (new Date()).toLocaleTimeString() + ')');\n    }\n    resetCountDown() {\n        this.countDownFrom = appConfig_1.AppConfig.data.chat_timer * 60;\n        this.countDown = this.countDownFrom;\n        this.updateTimerNow();\n    }\n    updateTimerNow() {\n        this.textTimerNow.textContent = this.getRemainingTimeText();\n    }\n    getRemainingTimeText() {\n        const m = Math.floor(this.countDown / 60);\n        const s = this.countDown - m * 60;\n        return `${m}:${util_1.Util.toStringWithZero(s, 2)}`;\n    }\n    timerText2Config() {\n        const t = Number(this.textTimerValue.value);\n        if (isNaN(t) || this.isTimerPeriodValid(t) !== true) {\n            this.timerConfig2Text();\n        }\n        else {\n            this.setTimerPeriod(t);\n        }\n        return this.getTimerPeriod();\n    }\n    timerConfig2Text() {\n        this.textTimerValue.value = this.getTimerPeriod().toString();\n    }\n    getTimerPeriod() {\n        return appConfig_1.AppConfig.data.chat_timer;\n    }\n    isTimerPeriodValid(t) {\n        return (t >= 1 && t <= 99);\n    }\n    setTimerPeriod(t) {\n        if (this.isTimerPeriodValid(t)) {\n            appConfig_1.AppConfig.data.chat_timer = t;\n        }\n        return this.getTimerPeriod();\n    }\n    beginNotify() {\n        if (this.notifyTimerId >= 0) {\n            window.clearTimeout(this.notifyTimerId);\n        }\n        this.logArea.style.backgroundColor = appConfig_1.AppConfig.data.chat_notifyColor;\n        this.notifyTimerId = window.setTimeout(() => {\n            this.endNotify();\n        }, this.T_NOTIFY);\n    }\n    endNotify() {\n        this.logArea.style.backgroundColor = appConfig_1.AppConfig.data.chat_backColor;\n        this.notifyTimerId = -1;\n    }\n    configToScreen() {\n        this.logArea.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.chat_font_familyName);\n        this.logArea.style.fontSize = appConfig_1.AppConfig.data.chat_font_size + \"pt\";\n        this.logArea.style.fontWeight = appConfig_1.AppConfig.data.chat_font_isBold ? \"bold\" : \"normal\";\n        this.logArea.style.color = appConfig_1.AppConfig.data.chat_foreColor;\n        this.logArea.style.backgroundColor = appConfig_1.AppConfig.data.chat_backColor;\n        this.inputArea.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.chat_font_familyName);\n        this.inputArea.style.fontSize = appConfig_1.AppConfig.data.chat_font_size + \"pt\";\n        this.inputArea.style.fontWeight = appConfig_1.AppConfig.data.chat_font_isBold ? \"bold\" : \"normal\";\n        var foreColor = appConfig_1.AppConfig.data.chat_foreColor;\n        var backColor = appConfig_1.AppConfig.data.chat_backColor;\n        this.inputArea.style.color = foreColor;\n        this.inputArea.style.backgroundColor = backColor;\n        this.resetCountDown();\n    }\n    updateConfig() {\n        this.configToScreen();\n    }\n    setPaneToConfig() {\n    }\n    localize() {\n        this.setTitle(t_1.T.t(\"Chat\", \"Chat\") + util_1.Util.getShortcutParenthesized(\"R\"));\n    }\n    setTitle(title) {\n        this.titlebar.textContent = title;\n    }\n    focus() {\n        this.inputArea.focus();\n    }\n    toggle() {\n        if (utilDom_1.UtilDom.isDisplayed(this.pane)) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane, \"flex\");\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PaneChat = PaneChat;\n\n\n//# sourceURL=webpack:///./src/paneChat.ts?");

/***/ }),

/***/ "./src/paneContainers.ts":
/*!*******************************!*\
  !*** ./src/paneContainers.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PaneContainer3 = exports.PaneContainer2 = exports.PaneContainer1 = void 0;\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass PaneContainer1 {\n    constructor() {\n        this.pane = document.getElementById('pane1');\n        // nop\n    }\n    setDefault() {\n        this.pane.style.width = \"45%\";\n    }\n    setFullWidth() {\n        this.pane.style.width = \"100%\";\n    }\n}\nexports.PaneContainer1 = PaneContainer1;\nclass PaneContainer2 {\n    constructor() {\n        this.pane = document.getElementById('pane2');\n        // nop\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane, \"flex\");\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PaneContainer2 = PaneContainer2;\nclass PaneContainer3 {\n    constructor() {\n        this.pane = document.getElementById('pane3');\n        // nop\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane, \"flex\");\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PaneContainer3 = PaneContainer3;\n\n\n//# sourceURL=webpack:///./src/paneContainers.ts?");

/***/ }),

/***/ "./src/paneFkey.ts":
/*!*************************!*\
  !*** ./src/paneFkey.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PaneFkey = void 0;\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass PaneFkey {\n    constructor() {\n        this.pane = document.getElementById('fkey');\n        this.titlebar = document.getElementById('fkey-title');\n        this.outerTable = document.getElementById(\"fkey-table\");\n        this.localize();\n        this.fkeys = [\n            document.getElementById(\"fkey01\"),\n            document.getElementById(\"fkey02\"),\n            document.getElementById(\"fkey03\"),\n            document.getElementById(\"fkey04\"),\n            document.getElementById(\"fkey05\"),\n            document.getElementById(\"fkey06\"),\n            document.getElementById(\"fkey07\"),\n            null, null,\n        ];\n        this.configToScreen();\n    }\n    getName() { return \"PaneFkey\"; }\n    applyFont(el) {\n        el.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.fkey_font_familyName);\n        el.style.fontSize = appConfig_1.AppConfig.data.fkey_font_size + \"pt\";\n        el.style.fontWeight = appConfig_1.AppConfig.data.fkey_font_isBold ? \"bold\" : \"normal\";\n    }\n    applyColor(el) {\n        // special treatment because of browsers not align color of IME underline\n        var foreColor = appConfig_1.AppConfig.data.fkey_foreColor;\n        var backColor = appConfig_1.AppConfig.data.fkey_backColor;\n        el.style.color = foreColor;\n        el.style.backgroundColor = backColor;\n    }\n    configToScreen() {\n        //autoOpen: AppConfig.data.fkey_isOpen,\n        const labels = this.outerTable.getElementsByClassName(\"fkey-label\");\n        for (var label of labels) {\n            const el = document.getElementById(label.id);\n            if (el === null)\n                continue;\n            this.applyFont(el);\n        }\n        const inputs = this.outerTable.getElementsByClassName(\"fkey-input\");\n        for (var input of inputs) {\n            const el = document.getElementById(input.id);\n            if (el === null)\n                continue;\n            this.applyFont(el);\n            this.applyColor(el);\n        }\n        const texts = this.outerTable.getElementsByClassName(\"fkey-text-readonly\");\n        for (var text of texts) {\n            const el = document.getElementById(text.id);\n            if (el === null)\n                continue;\n            this.applyFont(el);\n        }\n    }\n    getFKey(index) {\n        if (index >= 0 && index < this.fkeys.length) {\n            const fkey = this.fkeys[index];\n            if (fkey != null) {\n                return fkey.value;\n            }\n        }\n        return \"\";\n    }\n    localize() {\n        this.setTitle(t_1.T.t(\"Shortcut\", \"Fkey\") + util_1.Util.getShortcutParenthesized(\"F\"));\n    }\n    setTitle(title) {\n        this.titlebar.textContent = title;\n    }\n    updateConfig() {\n        this.configToScreen();\n    }\n    setPaneToConfig() {\n    }\n    focus() {\n        var _a;\n        (_a = this.fkeys[0]) === null || _a === void 0 ? void 0 : _a.focus();\n    }\n    toggle() {\n        if (utilDom_1.UtilDom.isDisplayed(this.pane)) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane);\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PaneFkey = PaneFkey;\n\n\n//# sourceURL=webpack:///./src/paneFkey.ts?");

/***/ }),

/***/ "./src/paneInput.ts":
/*!**************************!*\
  !*** ./src/paneInput.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PaneInput = void 0;\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nclass PaneInput {\n    constructor() {\n        this.pane = document.getElementById('input');\n        this.titlebar = document.getElementById('input-title');\n        this.input1Vjs = document.getElementById(\"input1\");\n        this.input2Vjs = document.getElementById(\"input2\");\n        this.lastInput = 0;\n        this.isOnShow = false;\n        this.getFkey = (ix) => { return \"\"; };\n        this.doOnInput = (t) => { };\n        this.lastSendInput = '';\n        this.doOnEnter = (t) => { };\n        this.doOnUndo = () => { return \"\"; };\n        this.doOnErase = () => { };\n        this.localize();\n        this.input1Vjs.addEventListener(\"focus\", (ev) => {\n            this.lastInput = 0;\n        });\n        this.input2Vjs.addEventListener(\"focus\", (ev) => {\n            this.lastInput = 1;\n        });\n        this.input1Vjs.addEventListener(\"input\", (ev) => {\n            this.onInput(this.input1Vjs.value);\n        });\n        this.input2Vjs.addEventListener(\"input\", (ev) => {\n            this.onInput(this.input2Vjs.value);\n        });\n        this.input1Vjs.addEventListener(\"keydown\", (ev) => {\n            this.onType(this.input1Vjs, ev, this.input2Vjs);\n        });\n        this.input2Vjs.addEventListener(\"keydown\", (ev) => {\n            this.onType(this.input2Vjs, ev, this.input1Vjs);\n        });\n        this.configToScreen();\n    } // end of constructor\n    getName() { return \"PaneInput\"; }\n    getLastInput() {\n        if (this.lastInput !== 1) {\n            return this.input1Vjs.value;\n        }\n        else {\n            return this.input2Vjs.value;\n        }\n    }\n    setGetFkey(callback) { this.getFkey = (ix) => callback(ix); }\n    setDoOnInput(callback) { this.doOnInput = (t) => callback(t); }\n    onInput(text) {\n        if (text === this.lastSendInput)\n            return;\n        this.lastSendInput = text;\n        this.doOnInput(text);\n    }\n    setDoOnEnter(callback) { this.doOnEnter = (t) => callback(t); }\n    onEnter(text) { this.doOnEnter(text); }\n    setDoOnUndo(callback) { this.doOnUndo = () => callback(); }\n    onUndo() { return this.doOnUndo(); }\n    setDoOnErase(callback) { this.doOnErase = () => callback(); }\n    onErase() { this.doOnErase(); }\n    onType(el, ev, another_el) {\n        // Only on macOS, when some key is typed while IME input, ev.key is same as when not IME inputing.\n        // https://qiita.com/ledsun/items/31e43a97413dd3c8e38e\n        if (ev.keyCode === utilDom_1.UtilDom.KEY_CTRL) {\n            return;\n        }\n        if (ev.keyCode === utilDom_1.UtilDom.KEY_TAB) {\n            another_el.focus();\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n        }\n        else if (ev.keyCode === utilDom_1.UtilDom.KEY_ENTER) {\n            // if (UtilDom.isCommandOrControlPressed(ev) === true) {\n            //   this.replacePart(el, \"\\n\")\n            // } else {\n            this.onEnter(el.value);\n            el.value = \"\";\n            // }\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n        }\n        else if (ev.keyCode === utilDom_1.UtilDom.KEY_ESC) {\n            el.value = \"\";\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n        }\n        else {\n            const iFkey = utilDom_1.UtilDom.getCtrlOrFKeyNumber(ev) - 1;\n            if (iFkey >= 0 && iFkey < 7) {\n                const sFkey = this.getFkey(iFkey);\n                if (sFkey.length > 0) {\n                    this.replacePart(el, sFkey);\n                }\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n            }\n            else if (iFkey === 7) {\n                if (ev.shiftKey !== true) {\n                    this.enclose(el, appConfig_1.AppConfig.data.getParentheses1(), appConfig_1.AppConfig.data.getParentheses2());\n                }\n                else {\n                    this.enclose(el, appConfig_1.AppConfig.data.getParenthesesShift1(), appConfig_1.AppConfig.data.getParenthesesShift2());\n                }\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n            }\n            else if (iFkey === 8) {\n                const undone = this.onUndo();\n                if (undone.length > 0) {\n                    this.insertTop(el, undone);\n                }\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n            }\n        }\n        this.onInput(el.value);\n    }\n    applyStyle(el) {\n        el.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.input_font_familyName);\n        el.style.fontSize = appConfig_1.AppConfig.data.input_font_size + \"pt\";\n        el.style.fontWeight = appConfig_1.AppConfig.data.input_font_isBold ? \"bold\" : \"normal\";\n        // special treatment because of browsers not align color of IME underline\n        var foreColor = appConfig_1.AppConfig.data.input_foreColor;\n        var backColor = appConfig_1.AppConfig.data.input_backColor;\n        el.style.color = foreColor;\n        el.style.backgroundColor = backColor;\n    }\n    configToScreen() {\n        this.applyStyle(this.input1Vjs);\n        this.applyStyle(this.input2Vjs);\n    }\n    setPaneToConfig() {\n    }\n    insertTop(el, text) {\n        // HTMLInputElement.selectionStart/End must exist in types text/password/search/tel/url/week/month\n        const index = el.selectionEnd || 0;\n        el.value = text + el.value;\n        const newIndex = index + text.length;\n        el.blur(); // workaround for Chromium (setSelectionRange doesn't textarea's scrollTop)\n        el.setSelectionRange(newIndex, newIndex);\n        el.focus();\n    }\n    replacePart(el, replaced) {\n        // HTMLInputElement.selectionStart/End must exist in types text/password/search/tel/url/week/month\n        const index0 = el.selectionStart || 0;\n        const index1 = el.selectionEnd || 0;\n        const text0 = el.value.substring(0, index0);\n        const text1 = el.value.substring(index1);\n        el.value = text0 + replaced + text1;\n        const newIndex = index0 + replaced.length;\n        el.blur(); // workaround for Chromium (setSelectionRange doesn't textarea's scrollTop)\n        el.setSelectionRange(newIndex, newIndex);\n        el.focus();\n    }\n    enclose(el, strPre, strPost) {\n        // HTMLInputElement.selectionStart/End must exist in types text/password/search/tel/url/week/month\n        const index0 = el.selectionStart || 0;\n        const index1 = el.selectionEnd || 0;\n        const len = el.value.length;\n        el.value = strPre + el.value + strPost;\n        var newIndex0 = index0 + strPre.length;\n        var newIndex1 = index1 + strPre.length;\n        if (index0 === index1 && index1 === len) {\n            newIndex0 += strPost.length;\n            newIndex1 += strPost.length;\n        }\n        el.blur(); // workaround for Chromium (setSelectionRange doesn't textarea's scrollTop)\n        el.setSelectionRange(newIndex0, newIndex1);\n        el.focus();\n    }\n    updateConfig() {\n        this.configToScreen();\n    }\n    focus() {\n        if (this.lastInput === 1) {\n            this.input2Vjs.focus();\n        }\n        else {\n            this.input1Vjs.focus();\n        }\n    }\n    localize() {\n        this.setTitle(t_1.T.t(\"Input Window\", \"Input\") + util_1.Util.getShortcutParenthesized(\"I\"));\n    }\n    setTitle(title) {\n        this.titlebar.textContent = title;\n    }\n    toggle() {\n        if (utilDom_1.UtilDom.isDisplayed(this.pane)) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane, \"flex\"); // input pane is \"flex\"\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PaneInput = PaneInput;\n\n\n//# sourceURL=webpack:///./src/paneInput.ts?");

/***/ }),

/***/ "./src/paneMain.ts":
/*!*************************!*\
  !*** ./src/paneMain.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PaneMain = void 0;\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst contentManager_1 = __webpack_require__(/*! ./contentManager */ \"./src/contentManager.ts\");\nconst content_1 = __webpack_require__(/*! ./content */ \"./src/content.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nconst log_1 = __importDefault(__webpack_require__(/*! ./log */ \"./src/log.ts\"));\nconst mekikuAnalyzer_1 = __webpack_require__(/*! ./mekikuAnalyzer */ \"./src/mekikuAnalyzer.ts\");\nclass PaneMain {\n    constructor() {\n        this.pane = document.getElementById(\"display\");\n        this.mainText = document.getElementById(\"mainText\");\n        this.lineHeightChecker = document.getElementById(\"mainLineHeightChecker\");\n        this.mainCache = document.getElementById(\"mainCache\");\n        this.lineHeight = 0;\n        this.linesDisplayed = 6; // just an initial value\n        this.delimiter = \"\";\n        this.contents = new contentManager_1.ContentManager();\n        this.newItems = new Array();\n        this.undoQueue = new Array();\n        this.isViewerMode = false;\n        const arg = {\n            pane: this.pane,\n            mainText: this.mainText,\n            lineHeightChecker: this.lineHeightChecker,\n        };\n        this.scrollManager = new ScrollManager(arg);\n        this.scrollManager.setOnScroll(() => {\n            this.contents.proceedLine();\n            this.restructureMainText();\n            this.scrollManager.startScrollIfNeeded();\n        });\n        // exec finally in constructor. (in configToScreen, scroll.lineHeightPx is set.)\n        this.configToScreen();\n    }\n    getName() { return \"PaneMain\"; }\n    onScrollCancelForRestructure() {\n        this.updateScreenParameters();\n        this.contents.loopItemsFromTop((d) => {\n            return this.addMeasureItems(d);\n        });\n        this.restructureMainText();\n        this.scrollManager.startScrollIfNeeded();\n    }\n    getMainLog() {\n        return this.contents.getLog();\n    }\n    hasMainLog() {\n        return this.contents.hasLog();\n    }\n    /**\n     * add \"inner\" new item to main display.\n     *\n     * (notice) this affect real display and scroll.\n     * @param text new line (without newline)\n     */\n    addNewItem(data) {\n        const isUndone = this.undoIfQueued(data);\n        const d = mekikuAnalyzer_1.MekikuUnitDataClass.fromContent(data);\n        d.contentType = content_1.ContentType.DISPLAY;\n        d.id = data.senderID;\n        d.content = data.D;\n        if (isUndone) {\n            d.flag |= mekikuAnalyzer_1.MekikuUnitDataFlags.UNDONE;\n        }\n        this.contents.addLog(d);\n        if (isUndone) {\n            return; // undone item does not affect visible content\n        }\n        this.contents.loopItems((d) => {\n            return this.addMeasureItems(d);\n        });\n        this.restructureMainText();\n        this.contents.notifyPacketEnd();\n        this.scrollManager.startScrollIfNeeded();\n    }\n    /**\n     * add new gross (lines) to main display.\n     *\n     * (notice) this affect real display. scroll stops when argument has valid text.\n     * @param lines new lines\n     */\n    addNewGross(data) {\n        const d = mekikuAnalyzer_1.MekikuUnitDataClass.fromContent(data);\n        d.contentType = content_1.ContentType.GROSS;\n        d.id = data.senderID;\n        d.content = data.G;\n        this.contents.addLog(d);\n        this.contents.loopItems((d) => {\n            return this.addMeasureItems(d);\n        });\n        this.restructureMainText();\n        this.stopScrollAndJumpToLatest();\n    }\n    undoLastItem() {\n        const undoed = this.contents.undoLastItem();\n        if (undoed == null) {\n            return null;\n        }\n        this.contents.loopItems((d) => {\n            return this.addMeasureItems(d);\n        });\n        this.restructureMainText();\n        this.contents.notifyPacketEnd();\n        this.scrollManager.startScrollIfNeeded();\n        return undoed;\n    }\n    undoIfQueued(data) {\n        const ix = this.undoQueue.findIndex((dataUndo) => {\n            return (data.senderID === dataUndo.U_ID) && (data.sendTimeCount === dataUndo.U_SENDTIME);\n        });\n        if (ix < 0)\n            return false;\n        this.undoQueue.splice(ix, 1);\n        return true;\n    }\n    /**\n     * add new undo to main display.\n     */\n    addNewUndo(data) {\n        const undone = this.contents.undoItem(data.U_ID, data.U_SENDTIME);\n        if (undone == null) {\n            this.undoQueue.push(data);\n            return;\n        }\n        if (undone === false)\n            return;\n        this.contents.loopItems((d) => {\n            return this.addMeasureItems(d);\n        });\n        this.restructureMainText();\n        this.contents.notifyPacketEnd();\n        this.scrollManager.startScrollIfNeeded();\n    }\n    /**\n     * add new erase to main display\n     */\n    addNewErase(data) {\n        const erase = mekikuAnalyzer_1.MekikuUnitDataClass.fromContent(data);\n        erase.contentType = content_1.ContentType.ERASE;\n        erase.content = PaneMain.NEW_LINE.repeat(this.linesDisplayed + 1);\n        this.contents.addLog(erase);\n        this.contents.loopItems((d) => {\n            return this.addMeasureItems(d);\n        });\n        this.restructureMainText();\n        this.stopScrollAndJumpToLatest();\n    }\n    /**\n     * add (possibly) new item into temporary memory.\n     *\n     * assumption : call with main content and complements in one packet, then call notifyNewItemsFinish.\n     * @param newData item (mekiku's unit data, like d/g/e...) that can be new\n     */\n    notifyNewItem(newData) {\n        if (newData.contentType === content_1.ContentType.ERASE) {\n            newData.content = PaneMain.NEW_LINE.repeat(this.linesDisplayed + 1);\n        }\n        this.newItems.push(newData);\n    }\n    /**\n     * notify all items (in a bulk, mainly a packet) searched (and called notifyNewItem).\n     *\n     * Packets in mekiku contains multiple data (including complements),\n     * sometimes displaying text adds multiple data.\n     * So decision about handling packet is determined after all data be processed.\n     */\n    notifyNewItemsFinish() {\n        if (this.newItems.length < 1)\n            return;\n        for (const item of this.newItems) {\n            const f = this.contents.updateLog(item);\n        }\n        const flags = this.contents.getUpdateFlags();\n        if (flags === contentManager_1.MainUpdateFlags.NOP)\n            return;\n        this.newItems = new Array();\n        this.contents.loopItems((d) => {\n            return this.addMeasureItems(d);\n        });\n        if (flags & (contentManager_1.MainUpdateFlags.ERASE | contentManager_1.MainUpdateFlags.GROSS)) {\n            this.stopScrollAndJumpToLatest();\n        }\n        else {\n            this.restructureMainText();\n            this.contents.notifyPacketEnd();\n            this.scrollManager.startScrollIfNeeded();\n        }\n    }\n    /**\n     * Set latest display-log into main-text.\n     * No scrolling management, no log pointer management.\n     */\n    restructureMainText() {\n        const lines = this.contents.getDisplayLog();\n        const joined = this.joinAndCountLines(lines);\n        this.mainText.textContent = this.makeText(joined.v1);\n        return joined.v2;\n    }\n    jumpToLatest() {\n        let lines = this.contents.getDisplayLog();\n        let joined = this.joinAndCountLines(lines);\n        if (joined.v2 > this.linesDisplayed) {\n            this.contents.proceedLine(joined.v2 - this.linesDisplayed);\n            lines = this.contents.getDisplayLog();\n            joined = this.joinAndCountLines(lines);\n        }\n        this.mainText.textContent = this.makeText(joined.v1);\n    }\n    stopScrollAndJumpToLatest() {\n        this.scrollManager.cancelScroll(() => {\n            this.jumpToLatest();\n            this.contents.notifyPacketEnd();\n        });\n    }\n    joinAndCountLines(lines) {\n        const r = {\n            v1: lines.join(PaneMain.NEW_LINE),\n            v2: lines.length\n        };\n        return r;\n    }\n    makeText(src) {\n        return src.endsWith('\\n') ? src + PaneMain.NBSP : src;\n    }\n    /**\n     * add and measure the height of new item.\n     * @param d item to add and measure\n     * @returns divided lines\n     */\n    addMeasureItems(d) {\n        const result = this.divideTextIntoDisplayLines(d.content);\n        return result;\n    }\n    /**\n     * Divide text into displaying lines, each line is within pane width.\n     * If text contains newline, it consists single array item.\n     * (text=\"abcde\\nfghij\", returns [\"abcde\",\"\\n\",\"fghij\"].)\n     * @param text text to divide\n     */\n    divideTextIntoDisplayLines(text) {\n        const logicalLines = text.split(PaneMain.NEW_LINE);\n        var result = new Array();\n        for (var logicalLine of logicalLines) {\n            let lines = this.divideLineIntoDisplayLines(logicalLine);\n            result.push(...lines);\n        }\n        return result;\n    }\n    /**\n     * Divide single line into display-width lines.\n     *\n     * (notice)\n     * This utilize displayed height, so even this uses \"length\" and \"substring\",\n     * this can handle text segmentation such as emoji modifier, joined codepoints.\n     * @param line string to divide\n     */\n    divideLineIntoDisplayLines(line) {\n        const len = line.length;\n        var ix1 = 0;\n        var ix2 = len;\n        var ix2Min = ix1;\n        var ix2Max = ix2;\n        var result = new Array();\n        for (var i = 0; true; i++) {\n            this.mainCache.textContent = line.substring(ix1, ix2);\n            const b = this.mainCache.getBoundingClientRect();\n            const n = Math.round(b.height / this.lineHeight);\n            if (n <= 1) {\n                ix2Min = Math.max(ix2, ix2Min);\n                ix2 = Math.ceil((ix2Min + ix2Max) / 2);\n            }\n            else {\n                ix2Max = Math.min(ix2, ix2Max);\n                ix2 = Math.floor((ix2Min + ix2Max) / 2);\n            }\n            if (ix2Max - ix2Min <= 1) {\n                result.push(line.substring(ix1, ix2Min));\n                if (ix2Min >= len)\n                    break;\n                ix1 = ix2Min;\n                ix2Max = len;\n                ix2 = ix2Max;\n            }\n            if (i > 10000) { // infinite?\n                log_1.default.w('Error', `divideLineIntoDisplayLines cycle too much! arg:\\n${line}`);\n                break;\n            }\n        }\n        return result;\n    }\n    // ========== ========== Configuration ========== ==========\n    configToScreen() {\n        this.pane.style.backgroundColor = this.getBackColor();\n        this.applyFont(this.mainText);\n        this.mainText.style.lineHeight = this.getLineHeight() + \"%\";\n        this.applyFont(this.lineHeightChecker);\n        this.lineHeightChecker.style.lineHeight = this.getLineHeight() + \"%\";\n        this.applyFont(this.mainCache);\n        // 'transition-duration' is used only once.\n        const scrollMsecRules = utilDom_1.UtilDom.extractCSSRulesByText('transition-duration');\n        for (const rule of scrollMsecRules) {\n            // CSSRule is CSSStyleRule when CSSRule.type is STYLE_RULE\n            if (rule.type === CSSRule.STYLE_RULE) {\n                const styleRule = rule;\n                styleRule.style.transitionDuration = this.getScrollMsec() + \"ms\";\n            }\n        }\n        this.updateScreen();\n    }\n    updateScreen() {\n        this.updateScreenParameters();\n        this.scrollManager.cancelScroll(() => {\n            this.contents.loopItemsFromTop((d) => {\n                return this.addMeasureItems(d);\n            });\n            this.restructureMainText();\n            this.scrollManager.startScrollIfNeeded();\n        });\n    }\n    updateScreenParameters() {\n        this.mainCache.style.lineHeight = this.getLineHeight() + \"%\";\n        this.mainCache.style.width = this.mainText.getBoundingClientRect().width + \"px\";\n        const bL = this.lineHeightChecker.getBoundingClientRect();\n        this.lineHeight = bL.height;\n        this.scrollManager.lineHeightPx = this.lineHeight;\n        const bP = this.pane.getBoundingClientRect();\n        this.linesDisplayed = Math.floor(bP.height / this.lineHeight);\n        this.scrollManager.linesDisplayed = this.linesDisplayed;\n        // Log.w('Debug',`paneMain.updateScreenParameters pane-cw=${this.pane.clientWidth} text-width=${this.mainText.style.width} cache-width=${this.mainCache.style.width} pane:${JSON.stringify(bP)} th=${this.textHeight} lh=${this.lineHeight} #l=${this.linesDisplayed} bL:${JSON.stringify(bL)}}`)\n    }\n    applyFont(el) {\n        el.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(this.getFontFamily());\n        el.style.fontSize = this.getFontSize() + \"pt\";\n        el.style.fontWeight = this.isBold() ? \"bold\" : \"normal\";\n        el.style.color = this.getForeColor();\n        el.style.backgroundColor = this.getBackColor();\n    }\n    getFontFamily() {\n        return this.isViewerMode ? appConfig_1.AppConfig.data.main_v_font_familyName : appConfig_1.AppConfig.data.main_font_familyName;\n    }\n    // ==================== AppConfig Interface ====================\n    getFontSize() {\n        return this.isViewerMode ? appConfig_1.AppConfig.data.main_v_font_size : appConfig_1.AppConfig.data.main_font_size;\n    }\n    isBold() {\n        return this.isViewerMode ? appConfig_1.AppConfig.data.main_v_font_isBold : appConfig_1.AppConfig.data.main_font_isBold;\n    }\n    getForeColor() {\n        return this.isViewerMode ? appConfig_1.AppConfig.data.main_v_foreColor : appConfig_1.AppConfig.data.main_foreColor;\n    }\n    getBackColor() {\n        return this.isViewerMode ? appConfig_1.AppConfig.data.main_v_backColor : appConfig_1.AppConfig.data.main_backColor;\n    }\n    getLineHeight() {\n        return this.isViewerMode ? appConfig_1.AppConfig.data.main_v_lineHeight : appConfig_1.AppConfig.data.main_lineHeight;\n    }\n    getScrollMsec() {\n        return this.isViewerMode ? appConfig_1.AppConfig.data.main_v_scrollMsec : appConfig_1.AppConfig.data.main_scrollMsec;\n    }\n    // ==================== End of AppConfig Interface ====================\n    setViewerMode(isViewer) {\n        this.isViewerMode = isViewer;\n    }\n    updateConfig() {\n        this.configToScreen();\n    }\n    setPaneToConfig() {\n    }\n    focus() {\n    }\n    toggle() {\n        // NOP (just for implements Pane)\n    }\n    show() {\n        // NOP (just for implements Pane)\n    }\n    hide() {\n        // NOP (just for implements Pane)\n    }\n}\nexports.PaneMain = PaneMain;\nPaneMain.NEW_LINE = \"\\n\";\nPaneMain.NBSP = String.fromCharCode(160);\nclass ScrollManager {\n    constructor(arg) {\n        this.SCROLL_NAME = \"scroll\";\n        /** number of lines to display (part of them might be occulted) */\n        this.linesDisplayed = 0;\n        this.isScrolling = false;\n        this.isHalt = false;\n        /** function executed when single scroll ended. */\n        this.doOnScroll = () => { };\n        this.pane = arg.pane;\n        this.mainText = arg.mainText;\n        this.lineHeightChecker = arg.lineHeightChecker;\n        const b = this.lineHeightChecker.getBoundingClientRect();\n        this.lineHeightPx = b.height;\n        this.mainText.addEventListener(\"transitionend\", () => this.onScrollEnd());\n    }\n    /** set function executed when single scroll ended. */\n    setOnScroll(callback) { this.doOnScroll = () => callback(); }\n    onScrollEnd() {\n        this.isScrolling = false;\n        this.mainText.classList.remove(this.SCROLL_NAME);\n        this.setTop(0);\n        this.doOnScroll();\n    }\n    startScrollIfNeeded() {\n        if (this.isScrolling)\n            return;\n        if (this.isHalt)\n            return;\n        if (!this.isTextBottomBelowPane())\n            return; // text in pane, needless to scroll\n        // Do start scrolling.\n        this.isScrolling = true;\n        this.mainText.classList.add(this.SCROLL_NAME);\n        this.setTop(-this.lineHeightPx);\n    }\n    /**\n     * Stop scroll.\n     * If scrolling, text DIV jumps out of screen (top=-8000px) and back to zero after callback.\n     * @param callback [Async] procedure after scroll stopped (animation is disabled), executed even if not scrolling.\n     */\n    cancelScroll(callback) {\n        const wasScrolling = this.isScrolling;\n        this.isScrolling = false;\n        this.mainText.classList.remove(this.SCROLL_NAME);\n        if (wasScrolling) {\n            this.setTop(-8000); // Temporary, move out of screen\n        }\n        window.setTimeout(() => {\n            this.setTop(0);\n            callback();\n        }, 0);\n    }\n    setTop(top) {\n        this.mainText.style.transform = `translate(0px,${top}px)`;\n    }\n    moveToTopNow() {\n        this.mainText.classList.remove(this.SCROLL_NAME);\n        this.setTop(0);\n    }\n    isTextBottomBelowPane() {\n        const bPane = this.pane.getBoundingClientRect();\n        const bText = this.mainText.getBoundingClientRect();\n        const result = bText.bottom > bPane.bottom;\n        // console.log(`bPane=${JSON.stringify(bPane)} h=${h} btm=${btm} bText=${JSON.stringify(bText)} r=${result}`)\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/paneMain.ts?");

/***/ }),

/***/ "./src/paneMonitor.ts":
/*!****************************!*\
  !*** ./src/paneMonitor.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PaneMonitor = void 0;\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nconst content_1 = __webpack_require__(/*! ./content */ \"./src/content.ts\");\nconst log_1 = __importDefault(__webpack_require__(/*! ./log */ \"./src/log.ts\"));\nclass PaneMonitor {\n    /**\n     * Make member pane (materialize dialog)\n     */\n    constructor() {\n        this.onMemberNewJoined = member => { };\n        this.onMemberLeft = member => { };\n        this.members = [];\n        this.viewers = [];\n        this.pane = document.getElementById(\"monitor\");\n        this.titlebar = document.getElementById('monitor-title');\n        this.table = document.getElementById(\"monitorTable\");\n        this.fontChecker = document.getElementById(\"monitorFontChecker\");\n        this.header1 = document.getElementById(\"monitorHeader1\");\n        this.header2 = document.getElementById(\"monitorHeader2\");\n        this.footer = document.getElementById(\"monitorFooter\");\n        this.shortState = document.getElementById('short_state');\n        this.IX_NAME = 0;\n        this.IX_INPUT = 1;\n        this.N_COLUMNS = 2;\n        this.localize();\n        this.configToScreen();\n        this.updateFooter();\n        this.updateShortState();\n    }\n    getName() { return \"PaneMonitor\"; }\n    setOnNewJoined(callback) { this.onMemberNewJoined = m => callback(m); }\n    setOnLeft(callback) { this.onMemberLeft = m => callback(m); }\n    updateMember(member, data) {\n        if (member.memberType === content_1.MemberType.WEB_VIEWER) {\n            var ix = this.viewers.findIndex((info) => { return info.id === member.id; });\n            if (ix < 0) {\n                this.viewers.push(member);\n                this.updateFooter();\n                this.updateShortState();\n                if (content_1.ContentType.LOGIN in data) {\n                    this.onMemberNewJoined(member);\n                }\n            }\n            else {\n                const beforeList = this.viewers.splice(ix, 1, member);\n                if (beforeList.length === 1) {\n                    if (member.lastSequence !== (beforeList[0].lastSequence + 1)) {\n                        log_1.default.w('Warning', `Viewer [${member.id}](${member.name}) seq jump from ${beforeList[0].lastSequence} to ${member.lastSequence}`);\n                    }\n                }\n            }\n        }\n        else {\n            var ix = this.members.findIndex((info) => { return info.id === member.id; });\n            if (ix < 0) {\n                this.members.push(member);\n                this.addRow();\n                ix = this.members.length - 1;\n                this.updateShortState();\n                if (content_1.ContentType.LOGIN in data) {\n                    this.onMemberNewJoined(member);\n                }\n            }\n            else {\n                const beforeList = this.members.splice(ix, 1, member);\n                if (beforeList.length === 1) {\n                    if (member.lastSequence !== (beforeList[0].lastSequence + 1)) {\n                        log_1.default.w('Warning', `Member [${member.id}](${member.name}) seq jump from ${beforeList[0].lastSequence} to ${member.lastSequence}`);\n                    }\n                    if (member.inputContent == null && beforeList[0].inputContent != null) {\n                        member.inputContent = beforeList[0].inputContent;\n                    }\n                }\n            }\n            this.updateRow(ix, member);\n        }\n    }\n    updateFooter() {\n        this.footer.textContent = `${t_1.T.t(\"Number of Viewers\", \"General\")} : ${this.viewers.length}`;\n    }\n    updateShortState() {\n        this.shortState.textContent = `${t_1.T.t(\"Subtitler\", \"General\")} : ${this.members.length} , ${t_1.T.t(\"Viewer\", \"General\")} : ${this.viewers.length + 1}`;\n        // short_state is shown only when you are a viewer, so number of viewers is +1'ed\n    }\n    deleteMember(id) {\n        const ix = this.members.findIndex(info => { return info.id === id; });\n        if (ix >= 0) {\n            const leftMembers = this.members.splice(ix, 1);\n            this.removeRow(ix + 1);\n            if (leftMembers.length > 0) {\n                this.onMemberLeft(leftMembers[0]);\n            }\n        }\n        const ix2 = this.viewers.findIndex(info => { return info.id === id; });\n        if (ix2 >= 0) {\n            const leftMembers = this.viewers.splice(ix2, 1);\n            this.updateFooter();\n            if (leftMembers.length > 0) {\n                this.onMemberLeft(leftMembers[0]);\n            }\n        }\n        this.updateShortState();\n    }\n    clearMembers() {\n        this.members = [];\n        this.viewers = [];\n        this.clearRows();\n        this.updateFooter();\n        this.updateShortState();\n    }\n    configToScreen() {\n        //autoOpen: AppConfig.data.monitor_isOpen,\n        this.table.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.monitor_font_familyName);\n        this.table.style.fontSize = appConfig_1.AppConfig.data.monitor_font_size + \"pt\";\n        this.table.style.fontWeight = appConfig_1.AppConfig.data.monitor_font_isBold ? \"bold\" : \"normal\";\n        this.table.style.color = appConfig_1.AppConfig.data.monitor_foreColor;\n        this.table.style.backgroundColor = appConfig_1.AppConfig.data.monitor_backColor;\n        this.pane.style.backgroundColor = appConfig_1.AppConfig.data.monitor_backColor;\n        this.fontChecker.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.monitor_font_familyName);\n        this.fontChecker.style.fontSize = appConfig_1.AppConfig.data.monitor_font_size + \"pt\";\n        this.fontChecker.style.color = appConfig_1.AppConfig.data.monitor_backColor;\n        this.fontChecker.style.backgroundColor = appConfig_1.AppConfig.data.monitor_backColor;\n        this.footer.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.monitor_font_familyName);\n        this.footer.style.fontSize = appConfig_1.AppConfig.data.monitor_font_size + \"pt\";\n        this.footer.style.color = appConfig_1.AppConfig.data.monitor_foreColor;\n        this.footer.style.backgroundColor = appConfig_1.AppConfig.data.monitor_backColor;\n    }\n    clearRows() {\n        while (this.table.rows[1]) {\n            this.table.deleteRow(1);\n        }\n    }\n    addRow() {\n        const newRow = this.table.insertRow(-1);\n        this.addColumns(newRow, this.N_COLUMNS);\n    }\n    addColumns(row, n) {\n        for (var i = 0; i < n; i++) {\n            const cell = row.insertCell(-1);\n            const text = document.createTextNode(\"\");\n            cell.appendChild(text);\n        }\n    }\n    removeRow(ix) {\n        this.table.deleteRow(ix);\n    }\n    updateRow(ix, member) {\n        const row = this.table.rows[ix + 1];\n        const nameNode = row.cells[this.IX_NAME].firstChild;\n        const nameStr = (member.name != undefined) ? member.name : \"noname\";\n        if (nameNode) {\n            nameNode.data = nameStr;\n        }\n        const nameCell = row.cells[this.IX_NAME];\n        nameCell.title = member.id;\n        const inputNode = row.cells[this.IX_INPUT].firstChild;\n        const inputStrBase = (member.inputContent === undefined) ? \"\" : member.inputContent;\n        if (inputNode) {\n            const len = this.seekTextStartForShowAll(inputStrBase);\n            var inputStr = inputStrBase.substr(len);\n            inputNode.data = inputStr;\n        }\n        this.updateStates();\n    }\n    seekTextStartForShowAll(src) {\n        const lenMax = src.length;\n        const wMessage = utilDom_1.UtilDom.getWidth(this.header2);\n        this.fontChecker.textContent = src;\n        var w = utilDom_1.UtilDom.getWidth(this.fontChecker);\n        if (w <= wMessage)\n            return 0;\n        var len = Math.floor(lenMax / 2);\n        var upper = lenMax;\n        var lower = 1;\n        for (var i = 0; i < 10; i++) {\n            this.fontChecker.textContent = src.substr(lenMax - len, len);\n            w = utilDom_1.UtilDom.getWidth(this.fontChecker);\n            if (w > wMessage) {\n                if (len < upper) {\n                    upper = len;\n                }\n            }\n            else {\n                if (len > lower) {\n                    lower = len;\n                }\n            }\n            if (upper === (lower + 1))\n                return lenMax - lower;\n            len = Math.floor((upper + lower) / 2);\n        }\n        return lenMax - lower; // avoid infinite loop\n    }\n    updateStates() {\n    }\n    updateConfig() {\n        this.configToScreen();\n    }\n    localize() {\n        this.setTitle(t_1.T.t(\"Input Monitor\", \"Monitor\"));\n        this.updateFooter();\n        this.updateShortState();\n    }\n    setTitle(title) {\n        this.titlebar.textContent = title;\n    }\n    focus() {\n        // no operation\n    }\n    toggle() {\n        if (utilDom_1.UtilDom.isDisplayed(this.pane)) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane);\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PaneMonitor = PaneMonitor;\n\n\n//# sourceURL=webpack:///./src/paneMonitor.ts?");

/***/ }),

/***/ "./src/panePft.ts":
/*!************************!*\
  !*** ./src/panePft.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PanePft = void 0;\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass PanePft {\n    constructor() {\n        this.MAX_LINES_GROSS = 20;\n        this.NEWLINE = \"\\n\";\n        this.GROSS_DELIMITER = \"`@\" + this.NEWLINE;\n        this.COMMENT_IDENTIFIER = \"<-\";\n        this.COMMENT_IPTALK_ID = \"<--\";\n        this.paneIdsVjs = [\"pft1\", \"pft2\", \"pft3\"];\n        this.textIdsVjs = [\"pft1-text\", \"pft2-text\", \"pft3-text\"];\n        this.nameIdsVjs = [\"pft1-name\", \"pft2-name\", \"pft3-name\"];\n        this.nameTextIdsVjs = [\"pft1-name-text\", \"pft2-name-text\", \"pft3-name-text\"];\n        this.paths = [\"\", \"\", \"\"];\n        this.encodings = [\"utf-8\", \"utf-8\", \"utf-8\"];\n        this.lastUsed = 0;\n        this.fileTarget = -1; // pft index to set opened/saved text (it is necessary because file handling is asynchronous)\n        this.RESPONSE_KEYS = [\"Home\", \"End\", \"PageUp\", \"PageDown\", \"Shift\"];\n        this.pane = document.getElementById('pft');\n        this.titlebar = document.getElementById('pft-title');\n        this.buttonOpenFile = document.getElementById(\"pft-open-file\");\n        this.buttonSaveFile = document.getElementById(\"pft-save-file\");\n        this.buttonNextComment = document.getElementById(\"pft-next-comment\");\n        this.buttonPreviousComment = document.getElementById(\"pft-previous-comment\");\n        this.buttonNextPft = document.getElementById(\"pft-next-pft\");\n        this.buttonPreviousPft = document.getElementById(\"pft-previous-pft\");\n        this.isOnShow = false;\n        this.getFkey = (ix) => { return \"\"; };\n        this.doOnSend = (t) => { };\n        this.doOnGross = (t) => { };\n        this.doOnChange = (ta, tb) => { };\n        this.doOnOpenCommand = (i) => { };\n        this.doOnSaveCommand = (d, n) => { };\n        this.localize();\n        this.panes = new Array();\n        this.texts = new Array();\n        this.names = new Array();\n        this.nameTexts = new Array();\n        for (var i = 0; i < this.textIdsVjs.length; i++) {\n            const paneDiv = document.getElementById(this.paneIdsVjs[i]);\n            this.panes.push(paneDiv);\n            const nameDiv = document.getElementById(this.nameIdsVjs[i]);\n            this.names.push(nameDiv);\n            const nameTextSpan = document.getElementById(this.nameTextIdsVjs[i]);\n            this.nameTexts.push(nameTextSpan);\n            const textArea = document.getElementById(this.textIdsVjs[i]);\n            this.texts.push(textArea);\n            textArea.addEventListener(\"keydown\", (e) => {\n                const iFkey = utilDom_1.UtilDom.getCtrlOrFKeyNumber(e) - 1;\n                if (iFkey === 0) {\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    if (e.shiftKey) {\n                        const lines = this.getGrossLinesAndGoNext(textArea);\n                        this.onGross(lines);\n                    }\n                    else {\n                        const line = this.getCurrentLine(textArea);\n                        this.goNextLine(textArea);\n                        if (!line.startsWith(\"<-\")) {\n                            this.onSend(line);\n                        }\n                    }\n                    const texts = this.getMonitorLines(textArea);\n                    this.onChange(texts.v1, texts.v2);\n                }\n                else if (iFkey > 0 && iFkey < 7) {\n                    const sFkey = this.getFkey(iFkey);\n                    if (sFkey.length > 0) {\n                        this.insertText(textArea, sFkey);\n                    }\n                }\n                else if (iFkey === 7) {\n                    if (e.shiftKey) {\n                        this.parenthesizeShift(textArea);\n                    }\n                    else {\n                        this.parenthesize(textArea);\n                    }\n                }\n                if (utilDom_1.UtilDom.isCommandOrControlPressed(e)) {\n                    if (e.keyCode === utilDom_1.UtilDom.KEY_ARROW_DOWN) { // ArrowDown key\n                        this.doOnGoNextComment(textArea);\n                        e.preventDefault();\n                    }\n                    else if (e.keyCode === utilDom_1.UtilDom.KEY_ARROW_UP) { // ArrowUp key\n                        this.doOnGoPreviousComment(textArea);\n                        e.preventDefault();\n                    }\n                    else if (e.keyCode === utilDom_1.UtilDom.KEY_ARROW_LEFT) { // ArrowLeft\n                        this.doOnGoPreviousPft(textArea);\n                        e.preventDefault();\n                    }\n                    else if (e.keyCode === utilDom_1.UtilDom.KEY_ARROW_RIGHT) { // ArrowRight\n                        this.doOnGoNextPft(textArea);\n                        e.preventDefault();\n                    }\n                    else if (e.keyCode === utilDom_1.UtilDom.KEY_O) { // o key\n                        e.preventDefault();\n                        e.stopImmediatePropagation();\n                        this.onOpenCommand(this.lastUsed);\n                    }\n                    else if (e.keyCode === utilDom_1.UtilDom.KEY_S) { // s key\n                        e.preventDefault();\n                        e.stopImmediatePropagation();\n                        this.onSaveCommand(this.lastUsed);\n                    }\n                    else if (e.keyCode === utilDom_1.UtilDom.KEY_K) { // k key\n                        e.preventDefault();\n                        e.stopImmediatePropagation();\n                        this.toggleComment(textArea);\n                    }\n                    else if (e.keyCode === utilDom_1.UtilDom.KEY_P) { // p key\n                        e.preventDefault();\n                        e.stopImmediatePropagation();\n                        this.insertGrossDelimiter(textArea);\n                    }\n                }\n            });\n            textArea.addEventListener(\"focus\", (ev) => {\n                this.lastUsed = parseInt(textArea.id.replace(/[^0-9]/g, \"\"), 10) - 1;\n                this.updateAllPftSizes();\n            });\n            textArea.addEventListener(\"input\", (e) => {\n                const texts = this.getMonitorLines(textArea);\n                this.onChange(texts.v1, texts.v2);\n            });\n            textArea.addEventListener(\"keyup\", (e) => {\n                if (e.key.includes(\"Arrow\") || this.RESPONSE_KEYS.includes(e.key)) {\n                    const texts = this.getMonitorLines(textArea);\n                    this.onChange(texts.v1, texts.v2);\n                }\n            });\n        }\n        // UtilJQuery.setPositionAndWidth(this.dialog, AppConfig.data.getPftBounds());\n        this.configToScreen();\n        this.setEventListeners();\n    }\n    getName() { return \"PanePft\"; }\n    setGetFkey(callback) { this.getFkey = (ix) => callback(ix); }\n    setOnSend(callback) { this.doOnSend = (t) => callback(t); }\n    onSend(text) { this.doOnSend(text); }\n    setOnGross(callback) { this.doOnGross = (t) => callback(t); }\n    onGross(lines) { this.doOnGross(lines); }\n    setOnChange(callback) { this.doOnChange = (ta, tb) => callback(ta, tb); }\n    onChange(ta, tb) { this.doOnChange(ta, tb); }\n    setOnOpenCommand(callback) { this.doOnOpenCommand = (i) => callback(i); }\n    onOpenCommand(i) {\n        this.fileTarget = i;\n        this.doOnOpenCommand(i);\n    }\n    setOnSaveCommand(callback) { this.doOnSaveCommand = (d, n) => callback(d, n); }\n    onSaveCommand(i) {\n        const text = this.texts[i].value || \"\";\n        this.fileTarget = i;\n        const name = this.nameTexts[i].textContent || \"\";\n        this.doOnSaveCommand(text, name);\n    }\n    NotifyPftOpened(text, file) {\n        this.nameTexts[this.fileTarget].textContent = file.name;\n        this.paths[this.fileTarget] = \"\";\n        this.encodings[this.fileTarget] = \"UTF-8\"; // currently only UTF-8 is supported\n        var area = this.texts[this.fileTarget];\n        this.fileTarget = -1; // reset\n        area.value = text;\n        area.blur();\n        area.setSelectionRange(0, 0);\n        area.focus();\n    }\n    NotifyPftSaved(name) {\n        this.nameTexts[this.fileTarget].textContent = name;\n        this.fileTarget = -1; // reset\n    }\n    setEventListeners() {\n        this.buttonNextComment.addEventListener(\"click\", (mouseEvent) => {\n            this.doOnGoNextComment(this.getCurrentPane());\n        });\n        this.buttonPreviousComment.addEventListener(\"click\", (mouseEvent) => {\n            this.doOnGoPreviousComment(this.getCurrentPane());\n        });\n        this.buttonNextPft.addEventListener(\"click\", (mouseEvent) => {\n            this.doOnGoNextPft(this.getCurrentPane());\n        });\n        this.buttonPreviousPft.addEventListener(\"click\", (mouseEvent) => {\n            this.doOnGoPreviousPft(this.getCurrentPane());\n        });\n        this.buttonOpenFile.addEventListener(\"click\", (e) => {\n            this.onOpenCommand(this.lastUsed);\n        });\n        this.buttonSaveFile.addEventListener(\"click\", (e) => {\n            this.onSaveCommand(this.lastUsed);\n        });\n    }\n    // ========== ========== methods for GUI operations ========== ==========\n    getCurrentPane() {\n        return this.texts[this.lastUsed];\n    }\n    getCurrentLine(area) {\n        const texts = this.splitText(area);\n        return texts.v2[0];\n    }\n    insertText(area, text) {\n        const pos = area.selectionStart;\n        const before = area.value.substr(0, pos);\n        const after = area.value.substr(pos);\n        const newPos = pos + text.length;\n        area.value = before + text + after;\n        area.blur();\n        area.setSelectionRange(newPos, newPos);\n        area.focus();\n    }\n    parenthesize(area) {\n        const pos = area.selectionStart;\n        const texts = this.splitText(area);\n        const currentLine = texts.v2.length > 0 ? texts.v2[0] : \"\";\n        const newLine = appConfig_1.AppConfig.data.getParentheses1() + currentLine + appConfig_1.AppConfig.data.getParentheses2();\n        const afterLines = texts.v2.length > 1 ? texts.v2.slice(1) : [];\n        const newPos = pos + appConfig_1.AppConfig.data.input_parentheses_1.length;\n        area.value = texts.v1.join(\"\\n\") + \"\\n\" + newLine + \"\\n\" + afterLines.join(\"\\n\");\n        area.blur();\n        area.setSelectionRange(newPos, newPos);\n        area.focus();\n    }\n    parenthesizeShift(area) {\n        const pos = area.selectionStart;\n        const texts = this.splitText(area);\n        const currentLine = texts.v2.length > 0 ? texts.v2[0] : \"\";\n        const newLine = appConfig_1.AppConfig.data.getParenthesesShift1() + currentLine + appConfig_1.AppConfig.data.getParenthesesShift2();\n        const afterLines = texts.v2.length > 1 ? texts.v2.slice(1) : [];\n        const newPos = pos + appConfig_1.AppConfig.data.input_parentheses_1.length;\n        area.value = texts.v1.join(\"\\n\") + \"\\n\" + newLine + \"\\n\" + afterLines.join(\"\\n\");\n        area.blur();\n        area.setSelectionRange(newPos, newPos);\n        area.focus();\n    }\n    toggleComment(area) {\n        const pos = area.selectionStart;\n        const texts = this.splitText(area);\n        const currentLine = texts.v2.length > 0 ? texts.v2[0] : \"\";\n        const posTopOfCurrentLine = util_1.Util.arraySum(texts.v1, (line) => line.length);\n        var newLine = \"\";\n        var newPos = pos;\n        if (currentLine.startsWith(this.COMMENT_IPTALK_ID)) {\n            const id_length = this.COMMENT_IPTALK_ID.length;\n            if (currentLine.length > id_length) {\n                newLine = currentLine.substring(id_length);\n                newPos = Math.max(pos - id_length, posTopOfCurrentLine);\n            }\n        }\n        else if (currentLine.startsWith(this.COMMENT_IDENTIFIER)) {\n            const id_length = this.COMMENT_IDENTIFIER.length;\n            if (currentLine.length > id_length) {\n                newLine = currentLine.substring(id_length);\n                newPos = Math.max(pos - id_length, posTopOfCurrentLine);\n            }\n        }\n        else {\n            const id_length = this.COMMENT_IDENTIFIER.length;\n            newLine = this.COMMENT_IDENTIFIER + currentLine;\n            newPos = pos + id_length;\n        }\n        const afterLines = texts.v2.length > 1 ? texts.v2.slice(1) : [];\n        var beforeLines = texts.v1.join(\"\\n\");\n        if (beforeLines.length > 0) {\n            beforeLines += \"\\n\";\n        }\n        area.value = beforeLines + newLine + \"\\n\" + afterLines.join(\"\\n\");\n        area.blur();\n        area.setSelectionRange(newPos, newPos);\n        area.focus();\n    }\n    insertGrossDelimiter(area) {\n        const pos = area.selectionStart;\n        const texts = this.splitText(area);\n        const newPos = pos + this.GROSS_DELIMITER.length;\n        var beforeLines = texts.v1.join(\"\\n\");\n        if (beforeLines.length > 0) {\n            beforeLines += \"\\n\";\n        }\n        area.value = beforeLines + this.GROSS_DELIMITER + texts.v2.join(\"\\n\");\n        area.blur();\n        area.setSelectionRange(newPos, newPos);\n        area.focus();\n    }\n    getMonitorLines(area) {\n        const texts = this.splitText(area);\n        const textA = (texts.v1.length >= 4) ? texts.v1.slice(-4) : texts.v1;\n        const textB = (texts.v2.length >= 10) ? texts.v2.slice(0, 10) : texts.v2;\n        return { v1: textA, v2: textB };\n    }\n    goNextLine(area) {\n        const pos = area.selectionStart;\n        const ix = area.value.indexOf(\"\\n\", pos);\n        if (ix >= 0) {\n            area.blur();\n            area.setSelectionRange(ix + 1, ix + 1);\n            area.focus();\n        }\n    }\n    getGrossLinesAndGoNext(area) {\n        const texts = this.splitText(area);\n        const candidate = (texts.v2.length <= this.MAX_LINES_GROSS)\n            ? texts.v2\n            : texts.v2.slice(0, this.MAX_LINES_GROSS);\n        const ix = candidate.findIndex((line) => {\n            return line === \"`@\";\n        });\n        if (ix < 0)\n            return [];\n        const res = candidate.slice(0, ix);\n        var aboveLen = 0;\n        texts.v1.forEach((line) => { aboveLen += line.length + 1; }); // +1:LF\n        var resLen = 0;\n        res.forEach((line) => { resLen += line.length + 1; }); // +1:LF\n        const newCaret = aboveLen + resLen + \"`@\\n\".length;\n        area.blur();\n        area.setSelectionRange(newCaret, newCaret);\n        area.focus();\n        return res;\n    }\n    jumpToPreviousComment(area) {\n        var ixNew = 0;\n        // search from the \"end of above line\"\n        const ix = area.value.lastIndexOf(\"\\n\", area.selectionStart - 1);\n        if (ix > 0) {\n            const ix2 = area.value.lastIndexOf(\"\\n<-\", ix - 1);\n            if (ix2 >= 0) {\n                ixNew = ix2 + 1; // only \"found previous comment\" case\n            }\n        }\n        area.blur();\n        area.setSelectionRange(ixNew, ixNew);\n        area.focus();\n    }\n    jumpToNextComment(area) {\n        const ix = area.value.indexOf(\"\\n<-\", area.selectionStart);\n        var ixNew = ix + 1;\n        if (ix < 0) {\n            const texts = this.splitText(area);\n            ixNew = area.value.length - texts.v2[texts.v2.length - 1].length;\n        }\n        area.blur();\n        area.setSelectionRange(ixNew, ixNew);\n        area.focus();\n    }\n    goNextPft(area) {\n        const n = this.textIdsVjs.indexOf(area.id);\n        if (0 <= n && n < (this.textIdsVjs.length - 1)) {\n            this.lastUsed++;\n            this.updateAllPftSizes();\n        }\n        this.getCurrentPane().focus();\n        return this.lastUsed;\n    }\n    goPreviousPft(area) {\n        const n = this.textIdsVjs.indexOf(area.id);\n        if (1 <= n && n < this.textIdsVjs.length) {\n            this.lastUsed--;\n            this.updateAllPftSizes();\n        }\n        this.getCurrentPane().focus();\n        return this.lastUsed;\n    }\n    doOnGoNextComment(textArea) {\n        this.jumpToNextComment(textArea);\n        const texts = this.getMonitorLines(textArea);\n        this.onChange(texts.v1, texts.v2);\n    }\n    doOnGoPreviousComment(textArea) {\n        this.jumpToPreviousComment(textArea);\n        const texts = this.getMonitorLines(textArea);\n        this.onChange(texts.v1, texts.v2);\n    }\n    doOnGoNextPft(textArea) {\n        const ix = this.goNextPft(textArea);\n        if (ix >= 0) {\n            const texts = this.getMonitorLines(this.texts[ix]);\n            this.onChange(texts.v1, texts.v2);\n        }\n    }\n    doOnGoPreviousPft(textArea) {\n        const ix = this.goPreviousPft(textArea);\n        if (ix >= 0) {\n            const texts = this.getMonitorLines(this.texts[ix]);\n            this.onChange(texts.v1, texts.v2);\n        }\n    }\n    // ========== ========== config ========== ==========\n    updatePftSize(el, index) {\n        if (appConfig_1.AppConfig.data.pft_show_isAll === true) {\n            const ratio = appConfig_1.AppConfig.data.pft_show_active_ratio;\n            const ratioMain = Math.floor(100 * ratio / ((ratio - 100) + 100 * this.texts.length));\n            const ratioOther = Math.floor(100 * 100 / ((ratio - 100) + 100 * this.texts.length));\n            // display all PFTs, ratio considered.\n            el.style.visibility = \"visible\";\n            if (index === this.lastUsed) {\n                el.style.flexBasis = ratioMain + \"%\";\n                el.style.flexGrow = String(ratio / 100);\n                el.style.flexShrink = String(ratio / 100);\n            }\n            else {\n                el.style.flexBasis = ratioOther + \"%\";\n                el.style.flexGrow = \"1\";\n                el.style.flexShrink = \"1\";\n            }\n        }\n        else {\n            // display single PFT\n            if (index === this.lastUsed) {\n                el.style.visibility = \"visible\";\n                el.style.flexBasis = \"100%\";\n                el.style.flexGrow = \"1\";\n                el.style.flexShrink = \"1\";\n            }\n            else {\n                el.style.visibility = \"hidden\";\n                el.style.flexBasis = \"0%\";\n                el.style.flexGrow = \"0\";\n                el.style.flexShrink = \"0\";\n            }\n        }\n    }\n    updateAllPftSizes() {\n        for (var i = 0; i < this.texts.length; i++) {\n            this.updatePftSize(this.panes[i], i);\n        }\n    }\n    applyFont(el) {\n        el.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.pft_font_familyName);\n        el.style.fontSize = appConfig_1.AppConfig.data.pft_font_size + \"pt\";\n        el.style.fontWeight = appConfig_1.AppConfig.data.pft_font_isBold ? \"bold\" : \"normal\";\n    }\n    applyColor(el) {\n        el.style.color = appConfig_1.AppConfig.data.pft_foreColor;\n        el.style.backgroundColor = appConfig_1.AppConfig.data.pft_backColor;\n    }\n    applyNameColor(el, ix) {\n        el.style.color = appConfig_1.AppConfig.data.pft_foreColor;\n        el.style.backgroundColor = (ix === this.lastUsed)\n            ? appConfig_1.AppConfig.data.pft_nameBackColor\n            : appConfig_1.AppConfig.data.pft_nameOtherBackColor;\n    }\n    applyAllStyles() {\n        for (var i = 0; i < this.texts.length; i++) {\n            this.applyFont(this.texts[i]);\n            this.applyColor(this.texts[i]);\n            this.applyFont(this.names[i]);\n            this.applyNameColor(this.names[i], i);\n            this.applyFont(this.nameTexts[i]);\n        }\n    }\n    configToScreen() {\n        // autoOpen: AppConfig.data.pft_isOpen,\n        appConfig_1.AppConfig.data.limitPftShowActiveRatio();\n        this.applyAllStyles();\n        this.updateAllPftSizes();\n    }\n    // ========== ========== in-class utility ========== ==========\n    splitText(area) {\n        const caretPos = area.selectionStart;\n        const linesTill = area.value.substr(0, caretPos).split(\"\\n\");\n        const linesAbove = (linesTill.length > 0) ? linesTill.slice(0, linesTill.length - 1) : [];\n        const lineTopPos = caretPos - linesTill[linesTill.length - 1].length;\n        const linesBelow = area.value.substr(lineTopPos).split(\"\\n\");\n        return { v1: linesAbove, v2: linesBelow };\n    }\n    // ========== ==========  ========== ==========\n    updateConfig() {\n        this.configToScreen();\n    }\n    localize() {\n        this.setTitle(t_1.T.t(\"PFT (Pre-Formatted Text)\", \"PFT\") + util_1.Util.getShortcutParenthesized(\"P\"));\n    }\n    setTitle(title) {\n        this.titlebar.textContent = title;\n    }\n    focus() {\n        if (0 <= this.lastUsed && this.lastUsed < this.texts.length) {\n            this.texts[this.lastUsed].focus();\n        }\n        else {\n            this.texts[0].focus();\n        }\n    }\n    toggle() {\n        if (utilDom_1.UtilDom.isDisplayed(this.pane)) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane, \"flex\");\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PanePft = PanePft;\n\n\n//# sourceURL=webpack:///./src/panePft.ts?");

/***/ }),

/***/ "./src/panePftMon.ts":
/*!***************************!*\
  !*** ./src/panePftMon.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PanePftMon = void 0;\nconst appConfig_1 = __webpack_require__(/*! ./appConfig */ \"./src/appConfig.ts\");\nconst t_1 = __webpack_require__(/*! ./t */ \"./src/t.ts\");\nconst utilDom_1 = __webpack_require__(/*! ./utilDom */ \"./src/utilDom.ts\");\nclass PanePftMon {\n    constructor() {\n        this.pane = document.getElementById(\"pftMon\");\n        this.titlebar = document.getElementById('pftMon-title');\n        this.logAbove = document.getElementById(\"pftMon-above\");\n        this.logText = document.getElementById(\"pftMon-log-text\");\n        this.logState = document.getElementById(\"pftMon-state\");\n        this.logStateText = document.getElementById(\"pftMon-state-text\");\n        this.container = document.getElementById(\"pftMon-log\");\n        this.isOnShow = false;\n        /** temporary \"above\" text storage for IPtalk (IPtalk sends each above lines and each below lines), so we need it */\n        this.aboveText = \"\";\n        this.belowText = \"\";\n        this.localize();\n        // PftMon does not have editable element, but \"Ctrl/Cmd+A\" should be \"Select-All\".\n        const parent = this.pane.parentElement;\n        if (parent != null) {\n            parent.addEventListener(\"keydown\", (ev) => { this.selectAllWhenCtrlA(ev); });\n        }\n        this.configToScreen();\n    }\n    getName() { return \"PanePftMon\"; }\n    selectAllWhenCtrlA(ev) {\n        if (ev.keyCode === utilDom_1.UtilDom.KEY_A && utilDom_1.UtilDom.isCommandOrControlPressed(ev)) { // a key\n            this.logText.focus();\n            this.logText.select();\n            ev.preventDefault();\n            ev.stopImmediatePropagation();\n        }\n    }\n    update(above, below, data) {\n        this.updateAbove(above);\n        this.updateBoth(above, below);\n        this.updateState(data.senderName);\n    }\n    updateAbove(str) {\n        // if above ends \\n, div ignores its height.\n        const strWithLastLine = (str.endsWith(\"\\n\")) ? str + \" \" : str;\n        this.logAbove.textContent = strWithLastLine;\n    }\n    updateBoth(strA, strB) {\n        if (strA.length > 0) {\n            this.logText.textContent = strA + \"\\n\" + strB;\n        }\n        else {\n            this.logText.textContent = strB;\n        }\n    }\n    updateState(str) {\n        if (str) {\n            this.logStateText.textContent = str + t_1.T.t(\"'s Pre-Formatted Text\", \"PftMon\");\n        }\n        else {\n            this.logStateText.textContent = t_1.T.t(\"'s Pre-Formatted Text\", \"PftMon\");\n        }\n    }\n    applyStyle(el) {\n        el.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.pftMon_font_familyName);\n        el.style.fontSize = appConfig_1.AppConfig.data.pftMon_font_size + \"pt\";\n        el.style.fontWeight = appConfig_1.AppConfig.data.pftMon_font_isBold ? \"bold\" : \"normal\";\n        el.style.color = appConfig_1.AppConfig.data.pftMon_foreColor;\n        el.style.backgroundColor = appConfig_1.AppConfig.data.pftMon_backColor;\n    }\n    applyFont(el) {\n        el.style.fontFamily = utilDom_1.UtilDom.makeFontFamily(appConfig_1.AppConfig.data.pftMon_font_familyName);\n        el.style.fontSize = appConfig_1.AppConfig.data.pftMon_font_size + \"pt\";\n        el.style.fontWeight = appConfig_1.AppConfig.data.pftMon_font_isBold ? \"bold\" : \"normal\";\n    }\n    configToScreen() {\n        // autoOpen: AppConfig.data.pftMon_isOpen,\n        this.applyFont(this.logAbove);\n        this.applyStyle(this.logText);\n        this.applyStyle(this.container);\n        this.applyStyle(this.logState);\n        this.applyStyle(this.logStateText);\n    }\n    updateConfig() {\n        this.configToScreen();\n    }\n    localize() {\n        this.setTitle(t_1.T.t(\"PFT Monitor\", \"PftMon\"));\n    }\n    setTitle(title) {\n        this.titlebar.textContent = title;\n    }\n    setPaneToConfig() {\n    }\n    focus() {\n        this.logText.focus();\n    }\n    toggle() {\n        if (utilDom_1.UtilDom.isDisplayed(this.pane)) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    }\n    show() {\n        utilDom_1.UtilDom.displayOn(this.pane, \"flex\");\n    }\n    hide() {\n        utilDom_1.UtilDom.displayOff(this.pane);\n    }\n}\nexports.PanePftMon = PanePftMon;\n\n\n//# sourceURL=webpack:///./src/panePftMon.ts?");

/***/ }),

/***/ "./src/t.ts":
/*!******************!*\
  !*** ./src/t.ts ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.T = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\n/**\n * very simple translation service class\n * [notice]\n * Both main and renderer processes need setLocale independently,\n * because T called from main and from renderer is different.\n */\nclass T {\n    constructor() {\n        // ========== ========== private  ========== ==========\n        this._locale = \"\";\n        this._failed = [];\n        this._dicts = {};\n        this._dict = null;\n        this.initDict();\n    }\n    static data() {\n        if (T._instance === null) {\n            T._instance = new T();\n        }\n        return T._instance;\n    }\n    static t(basePhrase, context) {\n        const phrase = T.data().getPhrase(basePhrase, context);\n        if (phrase === \"\")\n            return basePhrase;\n        if (util_1.Util.isMac()) {\n            phrase.replace(\"Ctrl+\", \"Cmd+\");\n        }\n        return phrase;\n    }\n    static a(basePhrase, context) {\n        return T.data().analyze(basePhrase, context);\n    }\n    /**\n     * check inner locale dictionaries and return locale that matches most.\n     * if fallback language (\"en\" or \"en-US\") was chosen, returns \"\".\n     *\n     * @param locale source locale string\n     * @example  assumption: dictionaries for \"ja\", \"th\", \"fr\" exist\n     * - matchLocale(\"en\") // \"\" (same as fallback language)\n     * - matchLocale(\"th\") // \"th\"\n     * - matchLocale(\"en-GB\") // \"\" (not exact \"en\", but near)\n     * - matchLocale(\"fr-CA\") // \"fr\" (near \"en\")\n     * - matchLocale(\"vi\") // \"\" (no match : fallback was chosen)\n     */\n    static matchLocale(locale) {\n        return T.data()._matchLocale(locale);\n    }\n    /**\n     * get locale from browser APIs.\n     * http://www1.kokusaika.jp/advisory/org/ja/js_point.html\n     * https://qiita.com/shogo82148/items/548a6c9904eb19269f8c\n     */\n    static getBrowserLocale() {\n        return (window.navigator.languages && window.navigator.languages[0])\n            || window.navigator.language;\n    }\n    /**\n     * set locale for localization.\n     * (if specified locale is not available, set fallback language (English).)\n     * @param locale locale string to set\n     */\n    static setLocale(locale) {\n        //const result = T.data().trySetLocale(locale);\n        // return result;\n        T.data().setInnerLocale(locale);\n        return true;\n    }\n    static getLocales() {\n        var locales = [\"en\"];\n        for (var locale of Object.keys(T.data()._dicts)) {\n            locales.push(locale);\n        }\n        locales.sort();\n        var result = [];\n        for (var locale of locales) {\n            if (locale === \"en\") {\n                result.push({ v1: \"en\", v2: \"English\" });\n                continue;\n            }\n            const d = T.data()._dicts[locale];\n            if (d === undefined)\n                continue;\n            const c = d[\"MyName\"];\n            if (c === undefined)\n                continue;\n            const p = c[\"English\"];\n            if (p === undefined)\n                continue;\n            result.push({ v1: locale, v2: p });\n        }\n        return result;\n    }\n    static getFails() {\n        return T.data().getAllFails();\n    }\n    // ========== ========== public instance methods  ========== ==========\n    _matchLocale(locale) {\n        // fallback languages\n        if (locale === \"en\" || locale === \"en-US\")\n            return \"\";\n        if (this._dicts[locale] !== undefined)\n            return locale;\n        const indexHyphen = locale.indexOf(\"-\");\n        if (indexHyphen <= 0)\n            return \"\";\n        const locale2 = locale.substr(0, indexHyphen);\n        if (this._dicts[locale2] !== undefined)\n            return locale2;\n        return \"\";\n    }\n    setInnerLocale(locale) {\n        this._locale = this._matchLocale(locale);\n        if (this._locale === \"\") {\n            this._dict = null;\n        }\n        else {\n            this._dict = this._dicts[this._locale];\n        }\n    }\n    trySetLocale(locale) {\n        // fallback languages\n        if (locale === \"en\" || locale === \"en-US\") {\n            this._locale = \"\";\n            this._dict = null;\n            return true;\n        }\n        const d = this._dicts[locale];\n        if (d !== undefined && d !== null) {\n            this._locale = locale;\n            this._dict = d;\n            return true;\n        }\n        const indexHyphen = locale.indexOf(\"-\");\n        if (indexHyphen <= 0)\n            return false;\n        const lang = locale.substr(0, indexHyphen);\n        const d2 = this._dicts[lang];\n        if (d2 !== undefined && d2 !== null) {\n            this._locale = lang;\n            this._dict = d2;\n            return true;\n        }\n        return false;\n    }\n    analyze(basePhrase, context) {\n        if (this._dict === null)\n            return `dict===null. return [${basePhrase}]`;\n        const phrases = this._dict[context];\n        if (phrases === undefined) {\n            return `dict[${context}] is undef.`;\n        }\n        const phrase = phrases[basePhrase];\n        if (phrase === undefined) {\n            return `phrases[${basePhrase}] is undef.`;\n        }\n        return `found [${phrase}]`;\n    }\n    getPhrase(basePhrase, context) {\n        if (this._dict === null)\n            return basePhrase;\n        const phrases = this._dict[context];\n        if (phrases === undefined) {\n            this._failed.push({ v1: basePhrase, v2: context });\n            return basePhrase;\n        }\n        const phrase = phrases[basePhrase];\n        if (phrase === undefined) {\n            this._failed.push({ v1: basePhrase, v2: context });\n            return basePhrase;\n        }\n        return phrase;\n    }\n    getAllFails() {\n        return this._failed;\n    }\n    initDict() {\n        this._dicts[\"ja\"] = {\n            \"MyName\": {\n                \"English\": \"\",\n            },\n            \"General\": {\n                \"OK\": \"OK\",\n                \"Cancel\": \"\",\n                \"Error\": \"\",\n                \"Warning\": \"\",\n                \"all files\": \"\",\n                \"file name\": \"\",\n                \"Subtitler\": \"\",\n                \"Viewer\": \"\",\n                \"Number of Viewers\": \"\",\n                \"Error occured on file access.\\nIf another application is using it, first quit it.\": \"\\n\",\n                \"Communication error.\": \"\",\n                \"Detail\": \"\",\n                \"Internet Explorer and old version of Microsoft Edge are not supported.\": \"Internet ExplorerMicrosoft Edge\",\n            },\n            \"Input\": {\n                \"Input Window\": \"\",\n            },\n            \"Chat\": {\n                \"Chat\": \"\",\n                \"Start\": \"\",\n                \"Halt\": \"\",\n                \"Reset\": \"\",\n                \"Increase Timer By A Minute\": \"1\",\n                \"Decrease Timer By A Minute\": \"1\",\n                \"0:00\": \"000\",\n                \"30 seconds to next turn.\": \"30\",\n                \" : \": \"\",\n                \"It's new turn now.\": \"\",\n                \"Timer started. Next \": \" \",\n                \"Timer halted.\": \"\",\n                \"login\": \"\",\n                \"New viewer joined.\": \"\",\n                \"logout\": \"\",\n                \"A viewer left.\": \"\",\n            },\n            \"Monitor\": {\n                \"Input Monitor\": \"\",\n                \"name\": \"\",\n                \"current input window\": \"\",\n                \"connect\": \"\",\n            },\n            \"PFT\": {\n                \"PFT (Pre-Formatted Text)\": \"\",\n                \"Open (Ctrl+O)\": \" (Ctrl+O)\",\n                \"Save As (Ctrl+S)\": \" (Ctrl+S)\",\n                \"Next Comment (Ctrl+down)\": \" (Ctrl+)\",\n                \"Previous Comment (Ctrl+up)\": \" (Ctrl+)\",\n                \"Next Window (Ctrl+right)\": \" (Ctrl+)\",\n                \"Previous Window (Ctrl+left)\": \" (Ctrl+)\",\n                \"PFT files\": \"\",\n                \"UTF-8 PFT files\": \"UTF-8\",\n                \"Unicode PFT files\": \"Unicode\",\n                \"text files\": \"\",\n            },\n            \"PftMon\": {\n                \"PFT Monitor\": \"\",\n                \"'s Pre-Formatted Text\": \"\",\n            },\n            \"Fkey\": {\n                \"Shortcut\": \"F\",\n                \"Parenthesize all\": \"\",\n                \"Undo\": \"1(undo)\",\n                \"(Not available)\": \"\",\n            },\n            \"Log\": {\n                \"Log\": \"\",\n            },\n            \"Login\": {\n                \"Login\": \"\",\n                \"LAN card\": \"LAN\",\n                \"Name\": \"\",\n                \"Channel\": \"\",\n                \"Group\": \"\",\n                \"The network port is occupied by other application.\\nSelect another channel and login.\": \"\\n\",\n                \"Network error occurs. Make sure network connection.\": \"\",\n                \"(No Network Available)\": \"LAN\",\n                \"Room\": \"\",\n                \"Viewer\": \"\",\n                \"Subtitler\": \"\",\n                \"Login failed.\": \"\",\n            },\n            \"Config\": {\n                \"Config\": \"\",\n            },\n            \"Config|General\": {\n                \"Font Size\": \"\",\n                \"Font Name\": \"\",\n                \"Font Color\": \"\",\n                \"Bold\": \"\",\n                \"Background Color\": \"\",\n                \"Show\": \"\",\n            },\n            \"Config|Misc\": {\n                \"General\": \"\",\n                \"Re-Login\": \"LAN\",\n                \"Full Screen\": \"\",\n                \"Select Language\": \"\",\n                \"To make your choice effective, Restart mekiku-M.\": \"mekiku-M\",\n                \"Save main log\": \"\",\n                \"Save chat log\": \"\",\n                \"Startup Settings\": \"\",\n                \"Keep Last Settings\": \"\",\n            },\n            \"Config|Main\": {\n                \"Main Display\": \"\",\n                \"Display style\": \"\",\n                \"Normal\": \"\",\n                \"Full Width\": \"\",\n                \"Full Window\": \"\",\n                \"Line Height\": \"1\",\n                \"Scroll interval per line\": \"1\",\n                \"msec\": \"\",\n            },\n            \"Config|Input\": {\n                \"Parentheses on F8 press\": \"F8\",\n                \"Parentheses on Shift+F8 press\": \"Shift+F8\",\n                \"\": \"\",\n                \"\": \"\",\n                \"(\": \"\",\n                \")\": \"\",\n            },\n            \"Config|Chat\": {\n                \"Notification Color\": \"\",\n            },\n            \"Config|Monitor\": {\n                \"Background Color On Loss\": \"\",\n            },\n            \"Config|PFT\": {\n                \"Background Color (Name)\": \"\",\n                \"Background Color (Name of Other Panes)\": \"\",\n                \"Display All\": \"\",\n                \"Current Window Width\": \"\",\n                \"Same As Others (x1.0)\": \"1.0\",\n                \"50% wider (x1.5)\": \"51.5\",\n                \"double (x2.0)\": \"22.0\",\n                \"triple (x3.0)\": \"33.0\",\n            },\n            \"Menu|Menu\": {\n                \"Menu\": \"\",\n                \"File\": \"\",\n                \"Edit\": \"\",\n                \"Re-Login\": \"LAN\",\n                \"Open Settings...\": \"...\",\n                \"Save Settings As...\": \"...\",\n                \"Config...\": \"...\",\n                \"Reset All Settings\": \"\",\n                \"Current As Default\": \"\",\n                \"Full Screen\": \"\",\n                \"Version...\": \"...\",\n                \"Exit\": \"\",\n                \"mekiku-M settings files\": \"mekiku-M\",\n                \"Undo\": \"\",\n                \"Cut\": \"\",\n                \"Copy\": \"\",\n                \"Paste\": \"\",\n                \"Select All\": \"\",\n            },\n        };\n        this._dicts[\"th\"] = {\n            \"MyName\": {\n                \"English\": \"\",\n            },\n            \"General\": {\n                \"OK\": \"OK\",\n                \"Cancel\": \"\",\n                \"Error\": \"\",\n                \"Warning\": \"\",\n                \"all files\": \"\",\n                // \"file name\" : \"\",\n                // \"Subtitler\" : \"\",\n                // \"Viewer\" : \"\",\n                // \"Number of Viewers\" : \"\",\n                \"Error occured on file access.\\nIf another application is using it, first quit it.\": \"\\n\\n\",\n            },\n            \"Input\": {\n                \"Input Window\": \"\",\n            },\n            \"Chat\": {\n                \"Chat\": \"\",\n                \"Start\": \"\",\n                \"Halt\": \"\",\n                \"Reset\": \"\",\n                \"Increase Timer By A Minute\": \" A \",\n                \"Decrease Timer By A Minute\": \" A \",\n                \"0:00\": \"0:00\",\n                \"30 seconds to next turn.\": \".\",\n                \" : \": \" : \",\n                \"It's new turn now.\": \"\",\n                \"Timer started. Next \": \"  \",\n                \"Timer halted.\": \" \",\n            },\n            \"Monitor\": {\n                \"Input Monitor\": \"\",\n                \"name\": \"\",\n                \"current input window\": \"\",\n                \"connect\": \"\",\n            },\n            \"PFT\": {\n                \"PFT (Pre-Formatted Text)\": \"\",\n                \"Open... (Ctrl+O)\": \"... (Ctrl+O)\",\n                \"Save As (Ctrl+S)\": \"... (Ctrl+S)\",\n                \"Next Comment (Ctrl+down)\": \" (Ctrl+down)\",\n                \"Previous Comment (Ctrl+up)\": \" (Ctrl+up)\",\n                \"Next Window (Ctrl+right)\": \" (Ctrl+right)\",\n                \"Previous Window (Ctrl+left)\": \" (Ctrl+left)\",\n                \"PFT files\": \" \",\n                \"UTF-8 PFT files\": \"UTF-8  \",\n                \"Unicode PFT files\": \"  \",\n                \"text files\": \"\",\n            },\n            \"PftMon\": {\n                \"PFT Monitor\": \"\",\n                \"'s Pre-Formatted Text\": \"\",\n            },\n            \"Fkey\": {\n                \"Shortcut\": \"\",\n                \"Parenthesize all\": \" \",\n                \"Undo\": \"\",\n                \"(Not available)\": \"()\",\n            },\n            \"Log\": {\n                \"Log\": \"\",\n            },\n            \"Login\": {\n                \"Login\": \" \",\n                \"LAN card\": \"\",\n                \"Name\": \"\",\n                \"Channel\": \"\",\n                \"Group\": \"\",\n                \"The network port is occupied by other application.\\nSelect another channel and login.\": \"\\n\\n\\n\",\n                \"Network error occurs. Make sure network connection.\": \" \\n\\n\",\n                \"(No Network Available)\": \"()\",\n            },\n            \"Config\": {\n                \"Config\": \" \",\n            },\n            \"Config|General\": {\n                \"Font Size\": \"\",\n                \"Font Name\": \"\",\n                \"Font Color\": \"\",\n                \"Bold\": \"\",\n                \"Background Color\": \"\",\n                \"Show\": \"\",\n            },\n            \"Config|Misc\": {\n                \"General\": \"\",\n                \"Re-Login\": \"\",\n                \"Full Screen\": \"\",\n                \"Select Language\": \"\",\n                \"To make your choice effective, Restart mekiku-M.\": \" ,  mekiku-M \",\n                \"Save main log\": \" ()\",\n                \"Save chat log\": \" ()\",\n                \"Startup Settings\": \"\",\n                \"Keep Last Settings\": \"\",\n            },\n            \"Config|Main\": {\n                \"Main Display\": \"\",\n                \"Display style\": \"\",\n                \"Normal\": \"\",\n                \"Full Width\": \"\",\n                \"Full Window\": \"\",\n                \"Line Height\": \"\",\n                \"Scroll interval per line\": \" \",\n                \"msec\": \"\",\n            },\n            \"Config|Input\": {\n                \"Parentheses on F8 press\": \" F8\",\n                \"Parentheses on Shift+F8 press\": \"Shift+F8\",\n                \"\": \"\\\"\\\"\",\n                \"\": \"\\\"\\\"\",\n                \"(\": \"(\",\n                \")\": \")\",\n            },\n            \"Config|Chat\": {\n                \"Notification Color\": \"\",\n            },\n            \"Config|Monitor\": {\n                \"Background Color On Loss\": \"  \",\n            },\n            \"Config|PFT\": {\n                \"Background Color (Name)\": \"()\",\n                \"Background Color (Name of Other Panes)\": \"()\",\n                \"Display All\": \"\",\n                \"Current Window Width\": \"\",\n                \"Same As Others (x1.0)\": \"\",\n                \"50% wider (x1.5)\": \" 1.5 \",\n                \"double (x2.0)\": \"2 \",\n                \"triple (x3.0)\": \"3 \",\n            },\n            \"Menu|Menu\": {\n                \"Menu\": \"\",\n                \"File\": \"\",\n                \"Edit\": \"\",\n                \"Re-Login\": \"\",\n                \"Open Settings...\": \" ...\",\n                \"Save Settings As...\": \" ...\",\n                \"Config...\": \" ...\",\n                \"Reset All Settings\": \"\",\n                \"Current As Default\": \"\",\n                \"Full Screen\": \"\",\n                \"Version...\": \" ...\",\n                \"Exit\": \"\",\n                \"mekiku-M settings files\": \" mekiku-M\",\n                \"Undo\": \"\",\n                \"Cut\": \"\",\n                \"Copy\": \"\",\n                \"Paste\": \"\",\n                \"Select All\": \"\",\n            },\n        };\n    }\n}\nexports.T = T;\n// singleton\nT._instance = null;\nT._isMac = false;\n\n\n//# sourceURL=webpack:///./src/t.ts?");

/***/ }),

/***/ "./src/util.ts":
/*!*********************!*\
  !*** ./src/util.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Util = void 0;\nclass Util {\n    /**\n     * Extract string 'before delimiter' or whole if delimiter is not included.\n     *\n     * beforeOf('abc/def', '/') === 'abc'\n     * beforeOf('abc/def', ':') === 'abc/def'\n     * beforeOf('abc/def', 'a') === ''\n     *\n     * @param src source string\n     * @param delimiter delimiter string\n     */\n    static beforeOf(src, delimiter) {\n        const ix = src.indexOf(delimiter);\n        if (ix < 0)\n            return src;\n        return src.substring(0, ix);\n    }\n    /**\n     * Check if a string is legit for room-name.\n     * @param name room name candidate\n     */\n    static isRoomNameLegit(name) {\n        const re = /^[A-Za-z0-9_-]+$/;\n        return re.test(name);\n    }\n    /**\n     * Check if a string contains one of substrings\n     * @param text string which is checked if contains one of substrings\n     * @param substrings string(s) which might be contained in text\n     */\n    static contains(text, ...substrings) {\n        for (const ix in substrings) {\n            if (text.indexOf(substrings[ix]) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * tell if argument is string or not.\n     * @param v value to detect\n     */\n    static isString(v) {\n        return typeof (v) === 'string' || v instanceof String;\n    }\n    /**\n     * tell if argument is number or not.\n     * https://zero-plus-one.jp/javascript/isnumber/\n     * @param val value to detect\n     */\n    static isNumber(val) {\n        return ((typeof val === 'number') && isFinite(val));\n    }\n    /**\n     * get UTC time in \"hh:mm:ss.sss\" format.\n     */\n    static getNowUTCTimeString() {\n        const n = new Date();\n        const h = n.getUTCHours().toString().padStart(2, '0');\n        const m = n.getUTCMinutes().toString().padStart(2, '0');\n        const s = n.getUTCSeconds().toString().padStart(2, '0');\n        const ms = n.getUTCMilliseconds().toString().padStart(3, '0');\n        return `${h}:${m}:${s}.${ms}`;\n    }\n    /**\n     * Sums up values in array (e.g. sum of lengths in string-array)\n     * @param array source values\n     * @param func function to get value for each item in the array\n     */\n    static arraySum(array, func) {\n        var sum = 0;\n        array.forEach((value, index, array) => {\n            sum += func(value, index, array);\n        });\n        return sum;\n    }\n    static toLf(src) {\n        return src.replace(/\\r\\n?/g, \"\\n\");\n    }\n    static toCrLf(src) {\n        return this.toLf(src).replace(/\\n/g, \"\\r\\n\");\n    }\n    /**\n     * Translate number into \"Zero-Padded\" string (like \"00123\")\n     * @param value the number translated to string\n     * @param digit the length of the result string\n     */\n    static toStringWithZero(value, digit) {\n        return (\"0\".repeat(digit) + value.toFixed(0)).slice(-digit);\n    }\n    static getNewLineCode() {\n        return this.isWin() ? \"\\r\\n\" : \"\\n\";\n    }\n    static isWin() {\n        const platform = window.navigator.platform.toLowerCase();\n        if (platform.includes(\"win\")) {\n            return true;\n        }\n        return false;\n    }\n    static isMac() {\n        const platform = window.navigator.platform.toLowerCase();\n        if (platform.includes(\"mac\")\n            || platform.includes(\"iphone\")\n            || platform.includes(\"ipad\")) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * provide shortcut-description string (ex. \"Ctrl+S\").\n     * on macOS, \"Cmd\" is used instead of \"Ctrl\".\n     * [notice] return value starts with space (u0020) because most usage need it.\n     * @param key character of shortcut-base-key. assuming \"R\",\"1\",...\n     */\n    static getShortcutTextRaw(key) {\n        if (key.length < 1)\n            return \"\";\n        const modifier = this.isMac() ? \"Cmd+\" : \"Ctrl+\";\n        return modifier + key.charAt(0);\n    }\n    /**\n     * provide shortcut-description string with leading space (ex. \" Ctrl+S\").\n     * on macOS, \"Cmd\" is used instead of \"Ctrl\".\n     * [notice] return value starts with space (u0020) because most usage need it.\n     * @param key character of shortcut-base-key. assuming \"R\",\"1\",...\n     */\n    static getShortcutText(key) {\n        if (key.length < 1)\n            return \"\";\n        return \" \" + this.getShortcutTextRaw(key);\n    }\n    /**\n     * provide shortcut-description string with leading space and parenthesized (ex. \" (Ctrl+S)\").\n     * on macOS, \"Cmd\" is used instead of \"Ctrl\".\n     * [notice] return value starts with space (u0020) because most usage need it.\n     * @param key character of shortcut-base-key. assuming \"R\",\"1\",...\n     */\n    static getShortcutParenthesized(key) {\n        if (key.length < 1)\n            return \"\";\n        return \" (\" + this.getShortcutTextRaw(key) + \")\";\n    }\n    /**\n     * provide shortcut (with shift key) description string (ex. \"Ctrl+Shift+S\").\n     * on macOS, \"Cmd\" is used instead of \"Ctrl\".\n     * [notice] return value starts with space (u0020) because most usage need it.\n     * @param key character of shortcut-base-key. assuming \"R\",\"1\",...\n     */\n    static getShiftShortcutTextRaw(key) {\n        if (key.length < 1)\n            return \"\";\n        var modifier = (this.isMac()) ? \"Shift+Cmd+\" : \"Ctrl+Shift+\";\n        return modifier + key.charAt(0);\n    }\n    /**\n     * provide shortcut (with shift key) description string with leading space (ex. \" Ctrl+Shift+S\").\n     * on macOS, \"Cmd\" is used instead of \"Ctrl\".\n     * [notice] return value starts with space (u0020) because most usage need it.\n     * @param key character of shortcut-base-key. assuming \"R\",\"1\",...\n     */\n    static getShiftShortcutText(key) {\n        if (key.length < 1)\n            return \"\";\n        return \" \" + this.getShiftShortcutTextRaw(key);\n    }\n    /**\n     * provide shortcut (with shift key) description string with leading space and parenthesized (ex. \" (Ctrl+Shift+S)\").\n     * on macOS, \"Cmd\" is used instead of \"Ctrl\".\n     * [notice] return value starts with space (u0020) because most usage need it.\n     * @param key character of shortcut-base-key. assuming \"R\",\"1\",...\n     */\n    static getShiftShortcutParenthesized(key) {\n        if (key.length < 1)\n            return \"\";\n        return \" (\" + this.getShiftShortcutTextRaw(key) + \")\";\n    }\n    static numberToText2(v) {\n        return v.toString().padStart(2, '0');\n    }\n    /**\n     * return current timestamp string as '2020-01-23_01:23:45'\n     */\n    static getIsoModifiedDateTimeString() {\n        const n = new Date();\n        const y = n.getFullYear().toString();\n        const m = this.numberToText2(n.getMonth() + 1);\n        const d = this.numberToText2(n.getDate());\n        const hh = this.numberToText2(n.getHours());\n        const mm = this.numberToText2(n.getMinutes());\n        const ss = this.numberToText2(n.getSeconds());\n        return `${y}-${m}-${d}_${hh}:${mm}:${ss}`;\n    }\n    /**\n     * return current timestamp string as '2020-01-23'\n     */\n    static getIsoStyleDateString() {\n        const n = new Date();\n        const y = n.getFullYear().toString();\n        const m = this.numberToText2(n.getMonth() + 1);\n        const d = this.numberToText2(n.getDate());\n        return `${y}-${m}-${d}`;\n    }\n    // Only for static-calling. Don't \"new\".\n    constructor() { }\n}\nexports.Util = Util;\n\n\n//# sourceURL=webpack:///./src/util.ts?");

/***/ }),

/***/ "./src/utilDom.ts":
/*!************************!*\
  !*** ./src/utilDom.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UtilDom = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"./src/util.ts\");\nclass UtilDom {\n    // For static use only. Do not 'new'.\n    constructor() { }\n    /**\n     * Get query string without leading '?'\n     * @returns query string if exists, or '' if query string does not exist\n     */\n    static getQuery() {\n        const q = location.search;\n        if (q.length > 0 && q[0] === '?') {\n            return q.substring(1);\n        }\n        return '';\n    }\n    /**\n     * Set query string in the address bar.\n     * @param query query string without leading '?'\n     */\n    static setQuery(query) {\n        history.replaceState({}, '', '?' + query);\n    }\n    static getWidth(el) {\n        if (!el)\n            return -1;\n        const b = el.getBoundingClientRect();\n        return b.width;\n    }\n    /**\n     * Show element by setting \"visibility\" style to \"visible\"\n     * @param el element to control\n     */\n    static show(el) {\n        if (el == null)\n            return;\n        el.style.visibility = \"visible\";\n    }\n    /**\n     * Hide element by setting \"visibility\" style to \"hidden\"\n     * @param el element to control\n     */\n    static hide(el) {\n        if (el == null)\n            return;\n        el.style.visibility = \"hidden\";\n    }\n    /**\n     * Returns the \"visibility\" style\n     * @param el element to detect\n     */\n    static isShown(el) {\n        if (el == null)\n            return false;\n        return el.style.visibility === 'visible';\n    }\n    /**\n     * Set \"display\" style to something\n     * @param el element to control\n     * @param display value to set\n     */\n    static displayOn(el, display = \"initial\") {\n        if (el == null)\n            return;\n        el.style.display = display;\n    }\n    /**\n     * Set \"display\" style to \"none\", so the element goes invisible\n     * @param el element to control\n     */\n    static displayOff(el) {\n        if (el == null)\n            return;\n        el.style.display = \"none\";\n    }\n    /**\n     * Return \"display\" style is other than \"none\"(invisible)\n     * @param el element to detect\n     */\n    static isDisplayed(el) {\n        if (el == null)\n            return false;\n        return el.style.display !== 'none';\n    }\n    static makeDialogsRespondToKey() {\n        for (const dialog of document.querySelectorAll(\"div.dialog\")) {\n            if (dialog.classList.contains(\"ignore_return\"))\n                continue;\n            const okRaw = dialog.querySelector(\"button.submit\");\n            const buttonOk = (okRaw != null) ? okRaw : undefined;\n            const cancelRaw = dialog.querySelector(\"button.cancel\");\n            const buttonCancel = (cancelRaw != null) ? cancelRaw : undefined;\n            for (const element of dialog.querySelectorAll('input[type=\"text\"]')) {\n                const el = element;\n                el.addEventListener('keydown', evKey => {\n                    if (evKey.keyCode === UtilDom.KEY_ENTER) {\n                        buttonOk === null || buttonOk === void 0 ? void 0 : buttonOk.click();\n                    }\n                    if (evKey.keyCode === UtilDom.KEY_ESC) {\n                        buttonCancel === null || buttonCancel === void 0 ? void 0 : buttonCancel.click();\n                    }\n                });\n            }\n            for (const element of dialog.querySelectorAll('input[type=\"password\"]')) {\n                const el = element;\n                el.addEventListener('keydown', evKey => {\n                    if (evKey.keyCode === UtilDom.KEY_ENTER) {\n                        buttonOk === null || buttonOk === void 0 ? void 0 : buttonOk.click();\n                    }\n                    if (evKey.keyCode === UtilDom.KEY_ESC) {\n                        buttonCancel === null || buttonCancel === void 0 ? void 0 : buttonCancel.click();\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * check if input string represents Function-Keys and return the number.\n     * (simply check the string format, like \"F1\", \"F12\". the number must be positive)\n     *\n     * returns : number (1 when F1, 2 when F2...) or -1 (function key is not pressed)\n     *\n     * @param key key value of key event\n     */\n    static getFKeyNumber(key) {\n        if (key.length < 2 || key.length > 3)\n            return -1;\n        if (key.charAt(0) !== \"F\")\n            return -1;\n        const n = Number(key.substr(1));\n        if (Number.isInteger(n) && n > 0)\n            return n;\n        return -1;\n    }\n    /**\n     * check if input string represents Function-Keys (F1-F12) and return the number.\n     *\n     * returns : number (1 when F1, 2 when F2...) or -1 (function key is not pressed)\n     *\n     * @param keyCode keyCode value of key event\n     */\n    static getFKeyNumberByKeyCode(keyCode) {\n        // Only on macOS, when some key is typed while IME input, ev.key is same as when not IME inputing.\n        // https://qiita.com/ledsun/items/31e43a97413dd3c8e38e\n        if (keyCode < 112 || keyCode > 123)\n            return -1;\n        return keyCode - 111;\n    }\n    /**\n     * Check if function key was pressed or (Control or Command) + number key were pressed.\n     * If so, return the number.\n     *\n     * returns : number (1 when F1 or CmdOrCtrl+1,...) or -1 (not pressed: function keys, CmdOrCtrl+number key)\n     *\n     * @param ev KeyboardEvent\n     */\n    static getCtrlOrFKeyNumber(ev) {\n        // const fkey = this.getFKeyNumber(ev.key);\n        const fkey = this.getFKeyNumberByKeyCode(ev.keyCode);\n        if (fkey >= 0) {\n            return fkey;\n        }\n        if (ev.key >= \"0\" && ev.key <= \"9\" && this.isCommandOrControlPressed(ev)) {\n            const n = parseInt(ev.key);\n            return n;\n        }\n        // if KeyboardEvent.code is available, use it. (because KeyboardEvent.key is affected by many things like shift key)\n        if (/^Digit[0-9]$/.test(ev.code) && this.isCommandOrControlPressed(ev)) {\n            const n = parseInt(ev.code.substr(5));\n            return n;\n        }\n        return -1;\n    }\n    /**\n     * Detect if Command (mac) or Control (other) key is pressed.\n     * @param ev KeyboardEvent\n     */\n    static isCommandOrControlPressed(ev) {\n        const platform = navigator.platform;\n        if (util_1.Util.isMac()) {\n            return ev.metaKey;\n        }\n        else {\n            return ev.ctrlKey;\n        }\n    }\n    /**\n     * Parse string (or null) into number.\n     * @param text target string (possibly null)\n     * @param defaultValue number returned when text is null.\n     */\n    static parseFloatEx(text, defaultValue = 0) {\n        if (text !== null) {\n            return parseFloat(text);\n        }\n        else {\n            return defaultValue;\n        }\n    }\n    /**\n     * Make CSS 'font-family' specifier (adding 'sans-serif')\n     * @param familyName name of font-family\n     * @param genericName generic font-family name if you want specify\n     */\n    static makeFontFamily(familyName, genericName = 'sans-serif') {\n        if (familyName === null || familyName.trim().length < 1)\n            return genericName;\n        if (familyName.trim() === genericName)\n            return familyName;\n        return familyName + ' , ' + genericName;\n    }\n    static addSelectOption(sel, text, value) {\n        const opt = document.createElement(\"option\");\n        opt.text = text;\n        opt.value = value;\n        sel.add(opt);\n    }\n    /**\n     * Extract all rules contains certain keyword in CSS text.\n     * @param keyword keyword to find in CSS text\n     */\n    static extractCSSRulesByText(keyword) {\n        return this.extractCSSRules(rule => rule.cssText.indexOf(keyword) >= 0);\n    }\n    /**\n     * Extract all rules matches certain condition.\n     * @param pred predicate to filter rules.\n     */\n    static extractCSSRules(pred) {\n        var result = [];\n        for (const sheet of document.styleSheets) {\n            for (const rule of sheet.cssRules) {\n                if (pred(rule)) {\n                    result.push(rule);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Get pressed modifier keys as number.\n     * Returns sum(pressed-modifier-key-value), value are among \"MK_\" constants.\n     * \"MK_\" constants are all different 2^n, so you can use bit operation.\n     * (example)\n     * - when control key pressed : MK_CTRL\n     * - when shift and alt keys pressed : MK_SHIFT | MK_ALT\n     * @param ev Keyboard event argument\n     */\n    static getModifierKey(ev) {\n        return (ev.shiftKey ? this.MK_SHIFT : 0)\n            + (ev.ctrlKey ? this.MK_CTRL : 0)\n            + (ev.altKey ? this.MK_ALT : 0)\n            + (ev.metaKey ? this.MK_META : 0);\n    }\n    /**\n     * Calc luminance of the argument-specified-color.\n     * Luminance is lightness of HLS color space (not HSV).\n     *\n     * returns luminance (0-255) or -1 (when argument is not \"#xxxxxx\" style)\n     *\n     * @param src color code (\"#xxxxxx\" style)\n     */\n    static getLuminance(src) {\n        const pattern = /^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/;\n        const result = pattern.exec(src);\n        if (result === null)\n            return -1;\n        if (result[3]) {\n            const r = parseInt(result[1], 16);\n            const g = parseInt(result[2], 16);\n            const b = parseInt(result[3], 16);\n            const rgbMax = Math.max(r, g, b);\n            const rgbMin = Math.min(r, g, b);\n            return (rgbMax + rgbMin) / 2;\n        }\n        return -1;\n    }\n}\nexports.UtilDom = UtilDom;\nUtilDom.MK_SHIFT = 1;\nUtilDom.MK_CTRL = 2;\nUtilDom.MK_ALT = 4;\nUtilDom.MK_META = 8;\nUtilDom.KEY_TAB = 9;\nUtilDom.KEY_ENTER = 13;\nUtilDom.KEY_CTRL = 17;\nUtilDom.KEY_ESC = 27;\nUtilDom.KEY_ARROW_LEFT = 37;\nUtilDom.KEY_ARROW_UP = 38;\nUtilDom.KEY_ARROW_RIGHT = 39;\nUtilDom.KEY_ARROW_DOWN = 40;\nUtilDom.KEY_A = 65;\nUtilDom.KEY_B = 66;\nUtilDom.KEY_C = 67;\nUtilDom.KEY_D = 68;\nUtilDom.KEY_E = 69;\nUtilDom.KEY_F = 70;\nUtilDom.KEY_G = 71;\nUtilDom.KEY_H = 72;\nUtilDom.KEY_I = 73;\nUtilDom.KEY_J = 74;\nUtilDom.KEY_K = 75;\nUtilDom.KEY_L = 76;\nUtilDom.KEY_M = 77;\nUtilDom.KEY_N = 78;\nUtilDom.KEY_O = 79;\nUtilDom.KEY_P = 80;\nUtilDom.KEY_Q = 81;\nUtilDom.KEY_R = 82;\nUtilDom.KEY_S = 83;\nUtilDom.KEY_T = 84;\nUtilDom.KEY_U = 85;\nUtilDom.KEY_V = 86;\nUtilDom.KEY_W = 87;\nUtilDom.KEY_X = 88;\nUtilDom.KEY_Y = 89;\nUtilDom.KEY_Z = 90;\n\n\n//# sourceURL=webpack:///./src/utilDom.ts?");

/***/ })

/******/ });